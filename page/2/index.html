<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">




  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">






  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="“吾生也有涯，而知也无涯”">
<meta property="og:type" content="website">
<meta property="og:title" content="曲率飞行">
<meta property="og:url" content="linqy71.github.io/page/2/index.html">
<meta property="og:site_name" content="曲率飞行">
<meta property="og:description" content="“吾生也有涯，而知也无涯”">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="曲率飞行">
<meta name="twitter:description" content="“吾生也有涯，而知也无涯”">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="linqy71.github.io/page/2/">





  <title>曲率飞行</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
  
    <a href="https://github.com/linqy71"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">曲率飞行</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">料青山见我应如是</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2020/07/08/Google论文-Bigtable阅读笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/08/Google论文-Bigtable阅读笔记/" itemprop="url">Google论文-Bigtable阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-08T11:00:06+08:00">
                2020-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文阅读/" itemprop="url" rel="index">
                    <span itemprop="name">论文阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11,971
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  42
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Bigtable-a-distributed-storage-system-for-structured-data"><a href="#Bigtable-a-distributed-storage-system-for-structured-data" class="headerlink" title="Bigtable: a distributed storage system for structured data"></a>Bigtable: a distributed storage system for structured data</h1><blockquote>
<p>本文为翻译版</p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Bigtable是一个用于管理结构化数据的分布式存储系统，数据可扩展到非常大的尺寸：几千个商业服务器上的大数据。许多Google项目把数据存储在Bigtable中，包括web indexing, Google Earth, Google Finance。从数据大小的角度或是延迟要求的角度来说，这些应用对于Bigtable有不同的要求。但尽管需求不同，Bigtable能够为这些产品提供灵活的、高性能的解决方案。本文描述了Bigtable提供的简单数据模型，该数据模型使得客户端能够动态控制数据布局和格式，并描述了Bigtable的设计和实现。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在过去的两年半时间里，我们设计、实现、部署了一个用于管理结构化数据的分布式存储系统——Bigtable。Bigtable的设计目的是使得大数据能够可靠地扩展到上千个机器上。Bigtable已经实现了几个目标：广泛的应用性、可扩展性、高性能、高可用性。Bigtable已经被用于六十多个Google产品和项目中。这些产品使用Bigtable来存放很多不同需求的负载，从面向吞吐量的批处理工作到延迟敏感的服务器数据。被这些产品所使用的Bigtable集群已经扩展了广泛的配置，存储了几百T的数据。</p>
<p>在许多方面，Bigtable类似于一个数据库：它与数据库共享许多实现方案。并行数据库和主存数据库已经取得了可扩展性和高性能，但Bigtable提供了跟这些系统不一样的接口。Bigtable不支持完整关系数据模型，相反，它为客户端提供了一个简单的可以支持对数据布局和格式动态控制的数据结构，使得客户端能够推测在底层存储中所表示的数据的位置属性。数据使用可以是任意字符串的行列名字作为下标。Bigtable把数据当成未翻译的字符串，尽管客户端经常将各种格式的结构化、半结构化数据序列化成这些未翻译字符串。客户端能够控制数据的位置(locality)通过选择他们的模式。最后，Bigtable模式参数使得客户端能够动态控制从内存还是硬盘中处理或访问数据。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>一个Bigtable是一个稀疏的、分布式的、持久的多维有序map。该map以一个row key、column key、timestamp作为index，map中的每个value是一个未翻译的字节数组。</p>
<p>在检查了一个类似于Bigtable系统的许多实用场景后我们选定了这个数据模型。一个具体的例子：假设我们想要保存一份存有大量网页和相关信息的表格，暂且将表格称为Webtable。在Webtable中，我们使用URL作为row key，使用网页的不同方面作为column names，将网页内容存储在contents中，contents是一个列。</p>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>表中的行key可以是任意字符串(目前大小上限为64KB，10-100字节是多数用户使用的大小)。对于一个row key的每次数据读写都是原子性的(atomic)，使得客户端能够在同一行中出现并发更新时更容易推断出系统行为。</p>
<p>Bigtable以row key的词典顺序维护数据。一个表的行区间(row range)是被动态分割的。每个行区间被称作一个tablet，是分布和负载均衡的单位。因此，短行区间的读是高效的并且通常只需要同少数机器进行通信。客户端能够通过选择他们的row key开发这个属性从而使得它们能够为数据访问获取数据的位置信息。例如，在Webtable中，某些领域的页面被并为一组存放在相邻的行中(通过翻转URL可以做到)。这种方式使得访问更加高效。</p>
<h3 id="列族-column-families"><a href="#列族-column-families" class="headerlink" title="列族 column families"></a>列族 column families</h3><p>column keys被划分为一些集合，这些集合成为column families，组成了访问控制的基本单位。存储在同一column familiy中的所有数据通常是同一种类型的。一个column family必须在数据存储到任何该family中的key之前创建。当一个family被创建之后，这个family中的任何column key都可以被使用。我们故意使得column family的数量保持在少数（最多几百个），而且families很少在操作过程中改变。相反，一个表中可能有无数个列。</p>
<p>一个column key的命名方式要遵循语法：family:qualifier。Column family 的名字必须是可打印的，qualifier就可以是任意字符串。例如：Webtable中的一个column family是language，存储了该web page对应的语言，该family中只有一个key，存储了language ID。另一个family是anchor，里面的每个key表示一个单独的anchor。如图1所示，qualifier表示相关网站，表格中的内容则是链接文本。</p>
<p>访问控制和硬盘、内存统计是在column family层面执行的。以Webtable为例，这些控制使得我们能够管理一些不同种类的应用：添加新的基数据、读取基数据和创建衍生的column family以及只允许浏览现有数据。</p>
<h3 id="时间戳-timestamps"><a href="#时间戳-timestamps" class="headerlink" title="时间戳 timestamps"></a>时间戳 timestamps</h3><p>Bigtable中的每个cell能够包含同一数据的不同版本。这些版本以时间戳为下表。Bigtable的时间戳是64位证书。它们能够被Bigtable本身所赋值或是被客户端应用显式赋值。客户端应用需要生成单独的时间戳以避免碰撞。一个cell的不同版本是按照时间戳递减顺序排列的，因此最近的版本会被最先访问。</p>
<p>为了更好地管理有版本的数据，我们支持两种设置使得Bigtable能够自动进行cell版本垃圾回收。客户端能够指定只有最新的n个版本能够被保留或是只有足够新的版本能够被保留(例如只保留最近7天内被写入的版本)。</p>
<p>以Webtable为例，我们设置这个存储在contents中的被爬下来的网页的时间戳…上面描述的垃圾回收机制使得每个页面只能保留最近的3个版本。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Bigtable API提供了一些用于创建和删除表、column family的方法。它也提供了一些改变cluster、table、column family metadata的方法，例如访问控制权限。</p>
<p>客户端应用能够写入或删除Bigtable中的数据，查找每个行中的数据或者是遍历表中数据的某个子集。</p>
<p>···<br>···</p>
<p>Bigtable支持一些其他的特性使得用户能够更复杂地操控数据。首先，Bigtable支持单行交易，能够用于执行原子性的对保存在单个row key中的数据的读写操作。Bigtable目前不支持通用的跨row key的交易，尽管它提供了一个跨row key批量写入数据的接口。其次，Bigtable允许每个cell被用作integer counters。最后，Bigtable支持在服务器的地址空间中执行客户端提供的脚本。这些脚本使用一种Google为了处理数据而开发的语言写的——Sawzall。目前，我们的基于Sawzall的API不支持客户端脚本写回Bigtable，但它允许不同的数据转化格式，以任意表达式过滤以及通过多种操作符总结。</p>
<p>Bigtable可以与MapReduce一起使用。MapReduce是Google开发的一个用于运行大规模并行计算的框架。我们已经封装了许多接口使得一个Bigtable既可以作为MapReduce job的输入又可以作为输出。</p>
<h2 id="building-blocks"><a href="#building-blocks" class="headerlink" title="building blocks"></a>building blocks</h2><p>Bigtable是基于一些其他的Google基础设施构建的。Bigtable使用分布式的Google File System(GFS)来存储日志文件和数据文件。一个Bigtable集群通常在一个共享池中被操作，池中包含了运行有其他分布式应用的机器。Bigtable进程经常与其他应用的进程共享同一台机器。Bigtable依赖一个集群管理系统来调度工作、管理共享机器的资源、处理机器错误以及监视机器状态。</p>
<p>Google SSTable文件格式用于存储Bigtable数据。一个SSTable提供了一个持久的、有序不变的map将key映射到value，其中key和value都是任意字符串。SSTable提供了查找跟特定key所关联的value的操作，或者是遍历特定key区间内的键值对。在内部，每个SSTable 包含一个块序列，通常每个块是64KB，但这个大小是可配置的。一个块的下标（储存在SSTable的末端）用于定位块，这个下标在SSTable被打开时载入内存。一个查找操作通过一次磁盘搜索便可以完成：首先通过对内存中的下标进行二分查找找到合适的块，再将该块从磁盘中读取出来。一个SSTable也可以完整映射到内存中，从而查找操作可以无需访问磁盘。</p>
<p>Bigtable依靠一个高可用和持久的分布式锁服务——Chubby。一个Chubby服务包含5个活跃的副本，其中一个被选举为master并响应请求。当多数的副本都处于运行状态并且能够互相通信时，服务即试做在线(live)。Chubby使用Paxos算法来保持副本之间的一致性。Chubby提供了一个命名空间包含了文件夹和一些小文件。每个文件夹或文件可以作为一个锁，对一个文件的读写是原子性的。Chubby客户端库提供一致的Chubby文件缓存服务。每个Chubby客户端维护一个session。当客户端的session无法在租约到期时间内更新他的session lease则session过期。当一个客户端session过期时，它释放所有的锁和已开启的handle。Chubby客户端能够为Chubby文件和文件夹注册回调函数用于通知变化或session过期时间。</p>
<p>Bigtable使用Chubby来完成各种任务：确保在任何时间最多只有一个活跃的master；保存Bigtable数据的bootstrap location；发现tablet服务器和中间tablet服务器的死亡；存储Bigtable的模式信息（每个表中的column family信息）；存储访问控制列表。如果Chubby持续一段时间内都不可用那么Bigtable也会变得不可用。我们在14个跨越了11个Chubby实例的Bigtable集群测量了这种影响。在Bigtable的服务时间内由于Chubby不可用造成存储在Bigtable中的数据不可用的时间平均占比为0.0047%，其中占比最高的单个集群为0.0326%。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Bigtable包含三个主要组件：链接到每个客户端的库、一个master server和许多tablet server。集群中的tablet server 能够动态添加或删除来适应负载的变化。</p>
<p>master负责分配tablets给tablet server， 删除额外的和过期的tablet server， 均衡 tablet server 的负载以及GFS中的文件的垃圾回收。并且，它还处理模式的变化例如表或column family的创建。</p>
<p>每个tablet server管理一个tablet集合（通常每个tablet server有10-1000个tablet）。tablet server处理它载入的tablet的读写请求并将变得过大的tablet切分开来。</p>
<p>就像许多单master的分布式存储系统一样，客户端数据不通过mater移动：客户端直接与tablet server进行读写通信。因为Bigtable客户端不依赖master来获取tablet 定位信息，多数的客户端从不与master通信。因此，master 在实际上是轻载的。</p>
<p>一个Bigtable集群存储了许多表。每个表包含了许多tablet，每个tablet包含了与一个行区间关联的所有数据。一开始，每个表只包含一个tablet。随着表的增长，它自动切分成了多个tablet，每个默认大小为100-200MB。</p>
<h3 id="tablet-location-（片位置）"><a href="#tablet-location-（片位置）" class="headerlink" title="tablet location （片位置）"></a>tablet location （片位置）</h3><p>我们使用一个类似于B+树的三层结构来储存片位置信息。</p>
<p>第一层是一个存储在Chubby中的文件，包含了根片（root tablet）的位置信息。根片包含了所有片的位置信息在一个特殊的METADATA表中。每个METADATA片包含了一个用户tablet集合的位置信息。根片是METADATA表的第一个片，它不会再被分解，确保了片位置信息层次不会超过三层。</p>
<p>METADATA表存储了一个片的位置信息在一个row key中，row key是这个片的表的标识以及它的末尾行的编码。每个METADATA行存储了大约1KB的数据在内存中。若METADATA的上限为128MB，那么这种三层的位置结构可以存储2^34个片。</p>
<p>客户端库存储了片位置。如果客户端不知道某个片的位置或者如果它发现了缓存中的位置信息是错误的，那么他就会递归地上升片位置层次。如果客户端缓存为空，那么定位算法需要3轮网络通信，包括一次对Chubby的读。如果客户端的缓存是被污染的，那么定位算法需要6轮网络访问，因为被污染的缓存条目只有在不命中时才会被发现。尽管片位置信息存储在内存中，已经无需访问GFS，我们还是进一步减少了内存开销，通过令客户端库预取片位置：无论何时读取METADATA表时都会读取不止一个片。</p>
<p>我们在METADATA表中也存储了一些次要信息，包括所有事件的日志等，有助于debug和性能分析。</p>
<h3 id="tablet-assignment-片分配"><a href="#tablet-assignment-片分配" class="headerlink" title="tablet assignment 片分配"></a>tablet assignment 片分配</h3><p>每个片一次只会分配给一个tablet server。master保持对活跃的tablet server集合的追踪，以及对tablet分配行为的追踪，包括未被分配的tablets。当一个片是未被分配的，并且有一个拥有足够空间的tablet server是可用的，那么master就会以发送一个tablet载入请求给server的形式将片分配给server。</p>
<p>Bigtable使用Chubby来追踪(track)tablet server。当一个tablet server开启，它创建并获得一个专用的锁在一个特殊Chubby文件夹的单一命名的文件上。master通过监控这个文件夹来发现其他的tablet server。如果这个专用的锁丢失了那么tablet server就会停止服务：例如：由于网络切分导致server丢失了Chubby session。Chubby提供了一个有效的机制能够使得tablet server在不引发网络拥塞的情况下可以检查它是否还保留着锁。只要文件还存在tablet server就会尝试重新获取文件锁。如果文件已经不存在了，则表示tablet server 无法再继续服务，因此它会将自己kill掉。当tablet server终结时(例如)它会尝试释放锁使得master能够更快地重新安排它的tablets。</p>
<p>master负责检测tablet server不再服务它的片了并且尽快重新安排这些片。为了检测tablet server是否不再服务它的片，master会定期询问每个server的锁状态。如果某个tablet server报告它已经丢失了它的锁，或者master经过几次尝试后都无法到达这个tablet server，master会尝试获取这个server的文件锁。如果master成功获取了这个文件锁那么Chubby是活跃的并且这个tablet server还未死亡或者只是无法获取Chubby，那么master会删除它的server文件来确保这个server不会再提供服务。一旦一个server的文件被删除，master能够移动这钱分配给这个server的所有的片进入未分配片的集合中。为了确保Bigtable集群不会轻易由于master和Chubby之间的网络原因受损，master会在Chubby session过期的时候杀死它自己。然而，尽管如上所述，master的failure不会改变对片的分配。</p>
<p>当master被集群管理系统启动的时候，它需要在改变片安排情况之前获取现有的片安排情况。master启动时执行这些操作：1)master在Chubby中抓取一个特殊的master锁，避免并发的master初始化；2)master扫描Chubby中的server文件夹来寻找存活的server；3)master和其他在线的tablet server通信以获取片分配情况；4)master扫描METADATA表。当扫描到了一个还未被分配的片时，master将这个片添加到未分配片集合中。</p>
<p>较为复杂的情况是对METADATA表的扫描只有在METADATA表已经被分配的情况下才能发生。因此，在扫描开始之前，master会添加根片到未分配片集合中如果在第3)步中对跟片的分配未被发现。这个附加条件确保了根片会被分配。因为根片包含了所有METADATA片的名字，master扫描根片之后便可以获取所有片名。</p>
<p>现有的片集合只有当一个表创建或删除、两个表的合并或一个表的切分时才会发生改变。master能够保持对这些变化的追踪。片切分会被特殊对待因为它们是被tablet server初始化的。tablet server会将新片的信息记录到METADATA表中。当信息成功提交后会通知master。万一切分的通知丢失了（由于tablet server或master的死亡引起的），master会检测新的片当它命令一个tablet server去载入已切分的片时。tablet server会通知master切分行为因为它在METADATA表中找到的tablet条目只会指定master要求装载的一部分片。</p>
<h3 id="tablet-serving"><a href="#tablet-serving" class="headerlink" title="tablet serving"></a>tablet serving</h3><p>片的持久状态被保存在GFS中。更新会被提交到一个保存了重做记录的日志中。在所有的更新中，最近提交的更新会被保存在一个有序的内存缓存中，称为memtable。旧的更新保存在一个SSTable序列中。为了记录一个片，tablet server会从METADATA表中读取数据。被读取的数据包含了SSTable列表，这个列表包含了一个片，一个重做点集合（指向提交日志中那些可能与该片有关的数据）。server读取这些指数到内存中并重新构建memtable通过应用这些在重做点后提交的更新。</p>
<p>当一个写操作到达tablet server的时候，server会检查它是否完好并检查发送者是否已授权。授权操作是通过读取Chubby文件中的允许写入者列表来确认的。(这个操作在Chubby客户端缓存中几乎总是命中的)。一个有效的突变会被写入提交日志中。提交分组被用来提高小突变的吞吐量。当写操作成功提交后，它的内容会被插入到memtable中。</p>
<p>当一个读操作到达tablet server的时候，server也会检查它是否完好并检查发送者是否已授权。一个有效的读操作会被执行以SSTable序列和memtable合并的视角来看。由于SSTable和memtable是按字典顺序排序的数据结构，因此合并操作非常高效。</p>
<p>当tablet被切分或合并时即将到来的读写操作可以持续进行。</p>
<h3 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h3><p>当写操作执行时，memtable的大小增加。当大小增加到一定的阈值是，memtable会被冻结，一个新的memtable会被常见，被冻结的表会转化成SSTable并写入到GFS中。这个最小压实操作有两个目标：1)收缩服务器的内存使用情况；2)减少当服务器死亡后恢复过程中需要从日志中读取的数据量。未来的读写操作可以在压实操作过程中持续进行。</p>
<p>每个最小压实操作会创建一个新的SSTable，如果这个行为没有被检测出来，读操作可能需要从任意多个SSTable中合并更新。相反，我们限制了这种文件的数量通过在后台定时执行一个合并压实操作。一个合并压实操作会从一些SSTable和memtable中读取内容并写入到新的SSTable中。当压实操作完成后作为输入的SSTable和memtable就可以被丢弃了。</p>
<p>一个合并压实操作会重写所有的SSTable到一个SSTable这种，这种操作成为主压实操作。由非主压实操作产生的SSTable可以包含特殊的删除条目，这些条目会抑制已经被删除的数据(但是在旧的SSTable中还存活的数据)。而主压实操作产生的SSTable不会包含删除信息以及被删除的数据。Bigtable循环遍历它的片并规律地执行主压实操作。这些主压实操作使得Bigtable能够澄清被已删除数据占用的资源并确保已删除的数据能够及时从系统中消失(对于存储敏感数据的服务来说非常重要)。</p>
<h2 id="Refinement"><a href="#Refinement" class="headerlink" title="Refinement"></a>Refinement</h2><p>上述章节描述的实现方法需要一些改进以获取更高的性能、可用性和可靠性。</p>
<h3 id="locality-groups"><a href="#locality-groups" class="headerlink" title="locality groups"></a>locality groups</h3><p>客户端可以将多个column family分组到一个locality组中。一个独立的SSTable会被创建用于每个tablet的每个locality组。分离那些不是很经常被访问的column family到一个单独的locality组中能够提高读效率。例如，Webtable中的网页元数据(例如语言或是访问量)可以处于一个locality组中，而内容可以处于另一个组中：一个想要读取元数据的应用不会需要读取网页内容。</p>
<p>另外，一些有用的平衡参数也能够被指定针对每一个locality组。例如，一个组可以被声明是保存在内存中的。用于保存在内存中的locality组的SSTable会被惰性地载入tablet server的内存中。一旦被载入，这些组中的column family能够在不访问磁盘的情况下被读取。这个特性对于一些频繁被访问的小片数据来说非常有用：我们在内部使用它为了定位METADATA表中的column family。</p>
<h3 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h3><p>客户端能够控制是否压缩一个locality组对应的SSTable，如果压缩，它还可以决定采用哪种压缩方式。用户指定的压缩方式会被应用到每个SSTable块中（块的大小是可控的通过一个特殊的参数）。尽管由于单独压缩每个块会浪费一些空间，但是读取的时候只需要取出一小部分而不是全部的文件就可以了。许多客户端采用传统的two-pass压缩方式。第一个pass使用Bentley and McIlroy’s Scheme，能够跨越大区间压缩长字符串。第二个pass是使用一个快速压缩算法来寻找一个16KB的小区间中的重复数据。两个pass都是非常快速的，编码速度100-200MB/s，解码速度400-1000MB/s。</p>
<p>尽管我们在选择算法时强调速度而不是节省的空间，这个压缩模式却表现优秀。例如，在Webtable中，我们使用这种压缩模式来存储网页内容。在我们的实验中，我们存储了很多文件在一个压缩的locality组中。为了达到实验目的，我们限制了每个文件只有1个版本。这种压缩方式实现了10:1的空间节省。这远好过GZip的3:1或4:1的压缩比，因为网页的行是这么分布的：单个host的所有网页存储的位置相邻。不仅是Webtable，还有很多应用选择行名使得相似的数据能够聚集在一块因而达到较高的压缩比。当Bigtable中存储了相同数据的多个版本时压缩比甚至能达到更高。</p>
<h3 id="caching-for-read-performance"><a href="#caching-for-read-performance" class="headerlink" title="caching for read performance"></a>caching for read performance</h3><p>为了提高读性能，tablet server使用2层缓存。高层的成为Scan Cache，缓存了由SSTable接口返回给tablet server代码的键值对。底层的是Block Cache，缓存了从GFS中读出来的SSTable块。Scan Cache对于那些倾向于重复读取相同数据的应用更有用。而Block Cache则对那些倾向于读取最近读取过的数据的应用更有用。</p>
<h3 id="Bloom-filers"><a href="#Bloom-filers" class="headerlink" title="Bloom filers"></a>Bloom filers</h3><p>一个读操作需要读取所有的SSTable来拼凑tablet的状态。如果SSTable不再内存中，最后还是需要访问磁盘。我们减少磁盘访问次数通过允许客户端指定在特定的locality组中的SSTable生成Bloom filter。一个Bloom filter可以使得我们可以询问一个SSTable是否包含某个特定行/列对的数据。对于某些应用，少量的tablet server内存用来存放Bloom filter可以减少由读操作引起的磁盘访问。我们使用Bloom filter同时也表明了大多数对不存在的行列的查找不需要访问磁盘。</p>
<h3 id="commit-log-implementation"><a href="#commit-log-implementation" class="headerlink" title="commit-log implementation"></a>commit-log implementation</h3><p>如果我们将每个片的提交日志保存在不同的日志文件中，那么GFS将会同时有大量的文件写入。这些写操作可能导致大量的磁盘搜索取决于每个GFS服务器的底层实现。并且，每个单独的日志文件会减少分组带来的优化。为了解决这些问题，我们将突变拼接到每个tablet server的提交日志中，再混合不同server的日志到同一个日志文件中。</p>
<p>使用单个日志文件提供了良好的性能优化，但灾难恢复变得更复杂。当一个tablet server死亡时，它所服务的片会被移动到很多其他的tablet server上:每个server只会载入少量的片。为了恢复片的状态，新的server需要重新应用突变到原本写好的提交日志上。然而，这些片的突变已经在同一个日志文件中混合。一个方法是令每个新的tablet server去读取完整的日志文件并恢复那些需要恢复的条目。但效率太低。</p>
<p>通过对提交的日志条目进行排序我们避免了重读的日志读取(根据 table、row name、log sequence number排序)。在排序后的输出中，一个特定的片的所有转变是相邻的因此能够通过一次磁盘搜索高效地读取。为了并行化排序，我们将日志文件划分为64MB大小的段，然后在不同的tablet server上并行地排序每个段。这种排序过程是由master协调的并且当一个tablet server表明他需要从日志文件中恢复一些变化时被初始化。</p>
<p>写日志到GFS中有时会导致性能瓶颈，有很多原因，例如写操作冲撞涉及到的GFS server，或者到达三个GFS服务器的指定集合的网络路径被阻塞或是高负载。为了保护突变免受延迟峰值的影响，每个tablet server实际上有2个写日志线程，每个线程写入它自己的日志文件，一次只有一个线程工作。如果写入的文件性能很差，那么就会切换到另一个线程。日志条目包含了序列号使得恢复过程可以避免由于线程切换造成的重复条目。</p>
<h3 id="speeding-up-tablet-recovery"><a href="#speeding-up-tablet-recovery" class="headerlink" title="speeding up tablet recovery"></a>speeding up tablet recovery</h3><p>如果master将一个片从一个tablet server移动到另一个，源server首先对该片执行一个最小压实操作。这个操作减少了恢复时间通过减少日志中未被压实的状态数量。压实结束后，源tablet server不再服务于这个片，在它真正卸载这个片之前，server执行另外一个（通常都非常快）最小压实操作来消除在第一个压实过程中到达的残留的未被压实的状态。当这两个压实操作完成后，该片会被装载到另一个server中而无需进行日志条目恢复。</p>
<h3 id="exploiting-immutability"><a href="#exploiting-immutability" class="headerlink" title="exploiting immutability"></a>exploiting immutability</h3><p>包括SSTable缓存在内，Bigtable系统的许多其他部分都被简化了，根据SSTable的不变性。例如，当读取SSTable时我们不需要任何对文件系统的并行访问。因此，对行的并行控制能够高效的实现。唯一可变的数据结构是memtable。为了减少读取memtable过程中产生的冲突，我们使每个memtable的行在写入时复制并且允许读写并行。</p>
<p>由于SSTable是不可变的，移除被删除的数据等同于对过时的SSTable进行垃圾回收。每个片的SSTable在METADATA表中注册。master移除过时的SSTable通过对SSTable集合进行一个mark-sweep垃圾回收操作，METADATA表中包含root集合。</p>
<p>最后，SSTable的不变性使得我们能够很快地切分片。我们令子片和父片共享一个SSTable而不是为每个子片重新生成SSTable。</p>
<h2 id="performance-evaluation"><a href="#performance-evaluation" class="headerlink" title="performance evaluation"></a>performance evaluation</h2><p>我们建立了N个tablet server的Bigtable集群来测量Bigtable随着N变化的性能和可扩展性。tablet server使用1GB内存，2个400GB IDE硬盘驱动来写入一个有1786个机器组成的GFS cell。N个客户端机器生成用来测试的Bigtable负载。我们使用同样数量的客户端作为tablet server来确保客户端不会成为瓶颈。每个机器有2个双核Opteron 2GHz芯片，足够的物理内存来装载正在运行的进程的工作集，以及一个单千兆以太网链路。这些机器会被安排成一个2层的树形的在根节点大约有100-200Gbps合成可用带宽的网络。所有的机器处于同一个主机中因此任何机器间的通信时间少于1毫秒。</p>
<p>tablet server、master、测试客户端、GFS server全都跑在同一个机器集合上，每个机器运行一个GFS server。一些机器也会运行tablet server或者一个客户端进程、或是同时处理其他工作。</p>
<p>R是测试中Bigtable的不同行key的数量。选择一个合适的R使得每个benchmark都会读写大约1GB的数据。</p>
<p>sequential write使用0-(R-1)作为行 key，行key空间被划分为10N个等大的区间。这些区间被一个中央调度器安排到N个客户端，只要客户端处理完上一个分配给它的区间这个调度器就会分配下一个可用的区间给客户端。这种动态分配消除了由其他运行在客户端上的进程产生的对性能的影响。我们在每个行key下写了一个字符串。每个字符串是随机生成的因此行是不可压缩的。而且，不同的行key下的字符串是不同的，因此跨行的压缩是不可能的。random write也是相似的除了行key被哈希后对R取模因此写负载被均匀得传播到每一个行空间。</p>
<p>benchmark介绍</p>
<p>—介绍sequential read</p>
<p>—介绍scan</p>
<p>—介绍random reads(mem)</p>
<h3 id="single-tablet-server-performance"><a href="#single-tablet-server-performance" class="headerlink" title="single tablet-server performance"></a>single tablet-server performance</h3><p>随机读取比任何其他操作都慢。每次随机读取涉及到将一个64KB的SSTable通过网络从GFS server传送到tablet server中，其中只有1000字节的值被使用。tablet server每秒大约执行1200次读，也就是能够从GFS中读取大约75MB每秒的数据。这样的带宽足够使得tablet server CPU饱和，由于网络堆栈中的开销、SSTable转化、Bigtable代码。而且这样的带宽也足够使得系统中的网络饱和。大多数Bigtable应用会减少块大小至8KB。</p>
<p>从内存随机读取是非常快的因为每1000字节的读取tablet server的内存就可以满足，而不需要从GFS读取一个大的64KB的块。</p>
<p>随机和顺序的写比随机读表现更好因为每个tablet server会拼接所有到来的写到一个单独的日志中并使用组提交来将这些写高效地流入GFS。在随机写和顺序写的性能方面没有太大差别。两种情况下，所有的写都会被记录到同一个日志中。</p>
<p>顺序读比随机读更优因为每个从GFS取出的64KB的SSTable块会被存储到块缓存中用于下一次的64读请求。</p>
<h3 id="scaling"><a href="#scaling" class="headerlink" title="scaling"></a>scaling</h3><p>当我们增加tablet server数量从1到500时总吞吐量也增加。例如，从内存的随机读取增加了300倍，当tablet server数量增加了500倍时。这种行为是因为这个benchmark的性能瓶颈是每个tablet server的CPU。</p>
<p>然而，性能并没有线性增加。对于大多数的benchmark来说，当tablet server的数量从1变成50的时候，每个server的吞吐量反而下降了。这种下降是因为负载不均衡，通常是因为其他进程抢夺了CPU和网络。我们的负载均衡算法尝试解决这种不均衡，但是无法完美：重新均衡被限制为减少tablet的移动（移动时一个tablet会短暂不可用，通常少于1秒）；由benchmark产生的负载会到处挪动。</p>
<p>随机读的benchmark表明了最坏的扩展性（当tablet server数量扩大500倍时总体吞吐量只提高了100倍）。这种行为是因为每1000个字节的读取都需要通过网络传输一个64KB的块。这种传输  使得1千兆以太网链路饱和，因此每个服务器的吞吐量会随着奇迹数量的增加而下降。</p>
<h2 id="Real-Application"><a href="#Real-Application" class="headerlink" title="Real Application"></a>Real Application</h2><p>截止2006年8月，已有388个非测试的Bigtable集群运行在不同的Google机器集群上，共有约24500个tablet server。</p>
<h3 id="Google-Analytics"><a href="#Google-Analytics" class="headerlink" title="Google Analytics"></a>Google Analytics</h3><p>Google Analytics 是一个帮助webmaster在网站上分析交通模式的服务。它提供了总体的数据，例如每日访问量以及每个URL每天的阅读量，以及一些网站分析报告，例如已经浏览了某个网页后进行购买的用户比例。</p>
<p>为了实现这个服务，webmaster嵌入了一个小JS程序在网页中。这个程序在网页被访问时触发。它记录了不同的Google Analytic请求信息，例如一个用户标识符和网页读取相关信息。Google Analytic总结了这些数据并使得它对webmaster可用。</p>
<p>我们简单描述了Google Analytics使用的两个表格。原生点击表格为每个端用户session维护一行，行名为包含了网站名字和session创建时间的组合。这种模式确保了访问同一个网站的session是连续的并按时间顺序排列。这个表格压缩到原来尺寸的14%。</p>
<h3 id="Google-Earth"><a href="#Google-Earth" class="headerlink" title="Google Earth"></a>Google Earth</h3><p>google为用户提供了高解决方案的卫星云图，通过基于网站的的Google地图接口和Google Earth。这些产品使得用户能够在地球表面穿梭：他们可以放大、旋转、浏览、标记卫星云图。这个系统使用一个表来预处理数据，还有一个不同表的集合来服务客户端数据。</p>
<p>预处理流水线使用一个表来存储原生图像数据。在预处理期间，图像被清洁和巩固到最终的服务数据。这个表包含了大约70T的数据因此是保存在磁盘中的。这些图像被有效压缩因此Bigtable压缩是不可用的。</p>
<p>图像表中的每行对应一个地理段。行的命名确保了相邻的地理段会保存在相近的位置。表中包含一个column family来追踪每个段的数据源。这个column family 有很多column：每个对应一个原生图像数据。由于每个段只是从几张图片构成的，因此这个column family十分稀疏。</p>
<p>预处理流水线十分依赖MapReduce来转化数据。总体的系统以1MB/s的速度处理每个tablet server的数据。</p>
<p>服务系统使用一个表来index存储在GFS中 数据。这个表非常小（大约500GB）但它必须在非常低的延迟下每秒每个数据中心服务成千上万个查询。因此，这个表由几百个tablet server持有并包含了存储在内存中的column family。</p>
<h3 id="Personalized-Search"><a href="#Personalized-Search" class="headerlink" title="Personalized Search"></a>Personalized Search</h3><p>Personalized Search是一个记录了用户对不同的Google产品例如网页搜索、图像、新闻的查询、点击操作。用户可以浏览他们的搜索历史来重新访问旧的查询和点击，他们可以寻求个性化的搜索结果。</p>
<p>Personalized Search在Bigtable存储了每个用户的数据。每个用户有单独的userid并且用这个userid命名了一个行。所有的用户行为被保存在一个表中。每种类型的行为预留一个单独column family（例如，有一个column family存储了所有web查询）。每个数据元素使用用户行为触发的事件作为Bigtable时间戳。Personalized Search使用对Bigtable的MapReduce生成用户描述，可以用于个性化的用户实时搜索结果。</p>
<p>Personalized Search数据在多个Bigtable集群中是重复的，为了提高可用性和由于客户端的距离产生的延迟。Personalized Search团队一开始创建了一个基于Bigtable的客户端副本机制为了确保所有副本的事件一致。这个系统现在使用服务器内部的一个复制子系统。</p>
<p>Personalized Search存储系统的这种设计使得其他的组能够添加新的用户信息到他们自己的column中，这个系统现在已经被多个其他需要个性化用户配置选项和设置的Google产品使用。不同组之间共享一个表造成了非常多的column family。为了支持这种共享，我们添加了一个简单的quota机制到Bigtable中来限制共享表中任一客户端的存储消耗。这种机制提供了不同的产品组之间的一些隔离。</p>
<h2 id="Lessons"><a href="#Lessons" class="headerlink" title="Lessons"></a>Lessons</h2><p>在设计、实现、维护和支持Bigtable的过程中，我们获得了有用的经历和有趣的教训。</p>
<p>一个教训是大的分布式系统对于很多类型的失败来说是易损的，不只是很多分布式协议中设想的标准的网络切分和fail-stop失败。例如，我们已经发现了很多由于以下原因导致的问题：内存和网络崩溃、大的时钟偏差、悬挂机器、扩展的和非对称的网络切分、其他正在使用的系统的bug、GFS quota移除、计划合非计划的硬件维护。我们使用多种协议来解决这些问题。例如，我们添加了校验和到RPC机制中。我们还通过移除了系统的一部分对另一部分所做的假设。例如，我们不再假设Chubby操作只能够返回固定的一组错误。</p>
<p>另一个教训是在新的特性没搞清楚之前不要急着添加。例如，我们一开始计划在我们的API中支持通用目的的交易。因为我们并没有立即用到这个功能，因此我们没有实现。现在我们已经有了很多真实的跑在Bigtable上的应用，我们能够检查他们实际的需求并且发现了大多数的应用只需要单行交易。当人们对分布式交易有需求时，最重要的是维护次要的指数，因此我们打算添加一个特殊的机制来满足这个需求。新的机制会比分布式交易更不通用一点，但会更高效（特别是对于跨越了几百个行的更新来说），并且会与我们的优化跨数据中心副本交互得更好。</p>
<p>一个很实用的教训是适当的系统层面监控是非常重要的（也就是说不仅监控Bigtable本身也监控使用了Bigtable的客户端进程）。例如，我们扩展了RPC系统使得对于一个RPC样来说他能够保持一个详细的对重要行为的记录。这个特性使得我们能够检测和修复许多问题，例如对tablet数据结构的锁争夺、提交Bigtable突变时写操作过慢、由于METADATA 片不可用造成的访问阻塞。另一个有效监控的例子是每个Bigtable集群都在Chubby中注册。这使得我们能够追踪所有的集群，发现他们的代销、观察我们的软件正在运行哪个版本、它们接收时是否拥塞、或者是否产生大的延迟等。</p>
<p>最终要的一个教训是简单设计的价值很高。由于系统的大小(大约10万行非测试代码)，以及代码随时间演变，我们发现代码和设计清晰度对后期的代码维护和debug非常重要。一个例子是tablet server的menbership协议。我们第一个协议非常简单：master定期发布租约到tablet server中，租约过期时tablet server杀死自己、然而这种协议在出现网络问题时可用性非常低，并且对master恢复时间敏感。我们又重新设计了协议。然而，最终的协议非常复杂并且依赖于一些很少被其他应用使用的Chubby特性的行为。我们在Chubby代码的晦涩案例上而不只是Bigtable代码上花费了太多时间。最终，我们废弃了这个协议并设计了一个新的简单协议，只依赖于那些广泛使用的Chubby特性。</p>
<h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>Boxwood项目有些组件与Chubby、GFS、Bigtable有重合，因为它提供了分布式agreement、锁、分布式chunk存储、分布式B树存储。在每种重合的情况下，Boxwood的组件针对的是更低层次的对象。Boxwood的目标是提供一个用于构建更高层次服务（例如文件系统或数据库）的框架，而Bigtable的目标是支持想要存储数据的客户端应用。</p>
<p>许多最近的项目已经解决了分布式存储或为广域网提供高层服务的问题。这包括对随着CAN、Chord、Tapestry等项目而开始的分布式哈希表的工作。这些系统强调了一些Bigtable没有出现的问题，例如高可变的带宽、不信任的参与者以及频繁的重配置。去中心化的控制和拜占庭容错不是Bigtable的目标。</p>
<p>从分布式数据存储模型的角度来说，我们相信有B树或分布式哈希表提供的键值对模型比较局限，相对于提供给应用开发者的模型来说。键值对是一个有用的构件块，但它们不应该是唯一一个提供给开发者的块。我们选择的模型比单一的键值对更丰富，并且支持稀疏的半结构化数据。尽管如此，它也是足够简单的，可以用高效的flat-file形式表示，并且足够透明，用户可以监控系统的重要行为。</p>
<p>许多数据库销售公司已经开发了并行数据库，可以存储大量的数据。Oracle的Real Application Cluster数据库使用共享磁盘来存储数据，一个分布式锁来管理。IBM的DB2 Parallel Edition基于一个与Bigtable类似的shared-nothing体系结构。每个DB2服务器负责一个表中的行子集，行子集存储在本地的关系数据库中。两个产品都提供了完整的关系模型，并支持交易。</p>
<p>Bigtable locality 组实现了相似的压缩和磁盘读取性能，通过以基于列的数据组织形式而不是基于行的形式来实现。另一个实现横向和纵向切分数据到平面文件中的系统并且实现了很高压缩率的系统是AT&amp;T的Daytona数据库。Locality组不支持CPU缓存层面的优化。</p>
<p>Bigtable使用memtable和SSTable来存储对片的更新，这种形式与Log-Structured Merger Three存储更新的形式相似。两个系统中，被排序的数据在被写入磁盘之前都缓存在内存中，而读操作必须合并内存和磁盘的数据。</p>
<p>C-store和Bigtable有一些相似的特性：都使用一个shared-nothing体系结构并且有两种不同的数据结构，一种用于最近的写，一种用于存储长寿命的数据，并且拥有移动数据的机制。两个系统在API方面不同：C-store表现为关系型数据库，然而Bigtable提供了一个更低层次的读写接口而且支持每个服务器每秒几千次操作。C-store也是一个读优化的关系型数据库管理系统，然而Bigtable为读写敏感的应用提供了更优的性能。</p>
<p>Bigtable的负载均衡器解决了一些与shared-nothing数据库面临的相同的问题。我们的问题更加简单：1）我们不考虑相同数据可能会有多个副本；2）我们让用户告知我们哪些数据是在内存中的而那些数据应该在磁盘中，而不是动态地去决定。3）我们无需执行或优化复杂的请求。</p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>我们已经描述了Bigtable——一个用于存储结构化数据的分布式系统。Bigtable集群自从2005年4月一来就投入生产，在此之前，我们已经花了将近7年的时间来设计和实现。截止2006年8月，超过60个项目正在使用Bigtable。我们的用户非常喜欢由Bigtable提供的性能和高可用性，他们能够简单地通过增加更多机器来扩展集群的容量。</p>
<p>考虑到Bistable一些不同寻常的接口，问题是对于用户来说他们适应的过程会有多难。新用户有时对于如何最好地使用Bigtable的接口并不确定，特别是当他们已经习惯于使用关系型数据库的情况下。尽管如此，许多成功使用Bigtable的Google产品证明了我们工作的实用性。</p>
<p>我们正继续开发几个额外的Bigtable特性，例如支持次要指数以及创建跨数据中心的Bigtable副本。我们也开始为产品组部署Bigtable作为服务，使得个人用户无需维护他们自己的集群。随着服务集群的扩展，我们需要解决很多Bigtable内部的资源共享问题。</p>
<p>最后，我们发现在Google搭建我们的解决方案有非常大的优势。我们在为Bigtable设计我们自己的数据模型时获得了大量的灵活性。而且，我们控制Bigtable的实现、以及其他Bigtable所依赖的Google组件，意味着我们能够随着问题的出现移除瓶颈和低效率的部分。</p>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2020/07/06/Redis学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/06/Redis学习/" itemprop="url">Redis学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-06T14:10:18+08:00">
                2020-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,427
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="了解Redis"><a href="#了解Redis" class="headerlink" title="了解Redis"></a>了解Redis</h1><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>REmote Dictionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p>
<p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>
<h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h2 id="Redis支持的数据结构"><a href="#Redis支持的数据结构" class="headerlink" title="Redis支持的数据结构"></a>Redis支持的数据结构</h2><ul>
<li>简单动态字符串 （simple dynamic string SDS）<ul>
<li>空间预分配：若SDS长度大于1MB，程序会分配1MB的未使用空间。</li>
<li>惰性空间释放</li>
<li>二进制安全</li>
<li>获取字符串长度为常数复杂度</li>
<li>杜绝缓冲区溢出</li>
</ul>
</li>
<li>链表</li>
<li>字典</li>
<li>跳跃表</li>
<li>整数集合（intset）<ul>
<li>不包含重复项</li>
<li>从小到大有序排列</li>
</ul>
</li>
<li>压缩列表（ziplist）<ul>
<li>压缩列表是为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序性数据结构</li>
<li>压缩链表可以包含多个节点，每个节点可以保存一个字节数组或整数值。</li>
</ul>
</li>
</ul>
<h2 id="Redis对象类型"><a href="#Redis对象类型" class="headerlink" title="Redis对象类型"></a>Redis对象类型</h2><ul>
<li>字符串对象 string</li>
<li>列表对象 list<ul>
<li>当列表元素较少时，使用压缩列表作为底层实现（所有字符串长度都小于64KB，且元素数量小于512）</li>
<li>当列表元素较多时，使用双端链表作为底层实现</li>
</ul>
</li>
<li>哈希对象 hash<ul>
<li>当所有键值对的键和值的字符串长度都小于64KB，且键值对数量小于512时，哈希对象采用压缩列表作为底层实现，每对键值保存在相邻位置。</li>
<li>否则采用hashtable编码，即采用字典作为底层实现，字典的每个键值都是字符串对象。</li>
</ul>
</li>
<li>集合对象 set<ul>
<li>当所有元素都是整数值且个数不超过512时，采用intset作为底层实现。</li>
<li>否则采用hashtable编码，即字典作为底层实现，字典的键对应集合中的元素，字典的值全部为NULL</li>
</ul>
</li>
<li>有序集合对象 zset<ul>
<li>当所有元素的长度小于64KB且数量小于128个时，采用ziplist作为底层实现</li>
<li>否则采用zset作为底层实现，zset结构同时包含一个字典和一个跳跃表，这两种数据结构通过指针共享相同的元素成员和分值。</li>
</ul>
</li>
</ul>
<h2 id="Redis的内存回收机制"><a href="#Redis的内存回收机制" class="headerlink" title="Redis的内存回收机制"></a>Redis的内存回收机制</h2><ul>
<li><p>引用计数机制：</p>
<ul>
<li>创建一个新对象时，引用计数的值被初始化为1</li>
<li>对象被一个新程序使用时，引用计数值加1</li>
<li>对象不再被一个程序使用时，引用计数值减1</li>
<li>对象的引用计数值为0时，对象所占用的内存会被释放<h2 id="Redis的对象共享机制"><a href="#Redis的对象共享机制" class="headerlink" title="Redis的对象共享机制"></a>Redis的对象共享机制</h2></li>
</ul>
</li>
<li><p>Redis中，多个键可以共享同一个值对象：</p>
<ul>
<li>将数据库的键指针指向一个现有的值对象</li>
<li>并将被共享的值对象的引用计数加1</li>
</ul>
</li>
<li><p>redis在初始化服务器时会创建一万个字符串对象，包含了从0-9999的所有整数值，当服务器要用到这些字符串对象时直接引用就可以了。</p>
</li>
</ul>
<h2 id="Redis的复制"><a href="#Redis的复制" class="headerlink" title="Redis的复制"></a>Redis的复制</h2><p>即主从服务器的同步。</p>
<ul>
<li>旧版复制功能：<ul>
<li>SYNC命令：<ul>
<li>主服务器执行BGSAVE命令生成RDB文件，此过程消耗大量的CPU、内存和磁盘I/O资源</li>
<li>发送RDB文件给从服务器，消耗网络资源</li>
<li>从服务器载入RDB文件时会因为阻塞而无法处理命令请求</li>
</ul>
</li>
</ul>
</li>
<li>新版复制功能：<ul>
<li>完整重同步：<ul>
<li>初次复制时使用完整重同步，操作与SYNC命令相同。</li>
</ul>
</li>
<li>部分重同步：<ul>
<li>用于断线后重新复制的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Redis源码探究"><a href="#Redis源码探究" class="headerlink" title="Redis源码探究"></a>Redis源码探究</h2><h3 id="Redis服务器"><a href="#Redis服务器" class="headerlink" title="Redis服务器"></a>Redis服务器</h3><ol>
<li><strong>server.h:</strong> redisServer结构体中含有服务器全局信息的相关属性</li>
<li><strong>server.c/main:</strong> 程序创建一个redisServer结构的实例变量 server ， 调用函数 initServerConfig() , 将 server 的各个属性初始化为默认值。</li>
<li><strong>server.c/main:</strong> 读入配置文件及参数设置等，打印log</li>
<li><strong>server.c/main:</strong> 配置完毕后启动aeMain，进入时间循环</li>
<li><strong>ae.c/aeMain:</strong> 循环执行aeProcessEvents直到接收到stop信号</li>
<li><strong>ae.c/aeProcessEvents:</strong> 调用multiplexing API – aeApiPoll，只有当超时或某些事件被触发时才会返回。</li>
<li><strong>ae_epoll.c/aeApiPoll:</strong> 调用epoll_wait接收请求，返回事件数量</li>
<li><strong>ae.c/aeProcessEvents:</strong> 根据返回的事件数量处理队列中的事件。一般情况下，首先处理读事件，再处理写事件。</li>
</ol>
<p>由于采用了I/O多路复用技术，即使有多个连接存在，Redis服务器在处理网络请求时也是单进程单线程的。</p>
<ul>
<li>优点：<ul>
<li>代码更清晰，处理逻辑更简单</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
<li>不存在多进程或者多线程导致的切换而消耗CPU</li>
</ul>
</li>
<li>缺点：<ul>
<li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li>
<li>（主从服务器如果部署在同一节点上，是否就失去了实用意义？）</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2020/06/29/垃圾回收功耗优化论文阅读/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/垃圾回收功耗优化论文阅读/" itemprop="url">垃圾回收功耗优化论文阅读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-29T22:01:27+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文阅读/" itemprop="url" rel="index">
                    <span itemprop="name">论文阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,329
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="垃圾回收功耗优化论文阅读"><a href="#垃圾回收功耗优化论文阅读" class="headerlink" title="垃圾回收功耗优化论文阅读"></a>垃圾回收功耗优化论文阅读</h1><h2 id="1-Heap-Compression-for-Memory-Constrained-Java-Environments"><a href="#1-Heap-Compression-for-Memory-Constrained-Java-Environments" class="headerlink" title="1. Heap Compression for Memory-Constrained Java Environments"></a>1. Heap Compression for Memory-Constrained Java Environments</h2><p>MS: Mark-Sweep<br>MC: Mark-Compact<br>MCC: Mark-Compact-Compress<br>MCL: Mark-Compact-Lazy<br>MCCL: Mark-Compact-Compress-Lazy</p>
<p>MS: “fregment problem”,即垃圾释放后空间碎片化问题</p>
<p>MC: </p>
<ul>
<li>Mark结束后，将存活对象整理到堆的一侧，另一侧释放后作为完整的空闲区域。</li>
<li>解决上述MS的问题。</li>
<li>缺点：移动了对象，所以对对象的引用(reference)也需要更新。</li>
</ul>
<p>MCC:</p>
<ul>
<li>标记存活对象并记录大小，由此得出剩余空间大小</li>
<li>当剩余空间小于请求分配的空间时，压缩存活对象以增加可用空间。</li>
<li>缺点：压缩和解压带来额外开销</li>
</ul>
<p>MCL：</p>
<ul>
<li>当一个对象被创建后，实际上用到的可能只有一小部分。</li>
<li>将大对象分解成几个子对象，当子对象遇到第一次写访问的时候才真正被allocated</li>
</ul>
<p>MCCL：</p>
<ul>
<li>MCC和MCL的结合，效果最优。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li><p>indirect object reference</p>
<ul>
<li>在handle pool中创建handle， 每个handle由指向instance的指针和指向class的指针构成。</li>
<li>当handle pool空间用尽时，GC被触发。</li>
<li>当handle pool的剩余空间小于某个阈值时，它会扩大。</li>
</ul>
</li>
<li><p>压缩</p>
</li>
<li>解压缩</li>
<li>将大对象分解</li>
<li>Lazy Allocation. 分解后的子对象直到第一次写访问时才被真正创建。</li>
</ol>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ul>
<li>主要对比的是运行过程中堆的使用情况。</li>
<li>MCCL各阶段所花的时间与MC所花时间的对比结果：<br><img src="/2020/06/29/垃圾回收功耗优化论文阅读/Fig13_in_paper1.png" alt=""></li>
</ul>
<h3 id="激进的对象压缩"><a href="#激进的对象压缩" class="headerlink" title="激进的对象压缩"></a>激进的对象压缩</h3><ul>
<li>原本，只有当compaction不足以提供足够的空闲空间用于分配时，compression才会被触发。</li>
<li>从实验结果看，对于heap memory较小的情况来说，激进的对象压缩能够一定程度减少MCCL原本所花的时间。</li>
</ul>
<h3 id="去掉handle-pool"><a href="#去掉handle-pool" class="headerlink" title="去掉handle pool"></a>去掉handle pool</h3><p>由于handle pool的大小很难确定，所以去掉它会更合适。由此带来的代价是压缩率轻微下降。</p>
<h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>与能耗、GC相关的：</p>
<p>Chen et al. [14]，提出能够降低嵌入式Java应用程序能耗的方法。证明了提高GC的频率有助于增加可以放入低功耗操作模式的bank的数量。<br>[14] G. Chen, R. Shetty, M. Kandemir, N. Vijaykrishnan, M. J. Irwin, and M. Wolczko. Tuning garbage collection in an embedded Java environment. In the 8th International Symposium on High-Performance Computer Architecture (HPCA’02), Cambridge, MA, USA, Feb. 2002. </p>
<p>逃逸分析（例如[16]）提供了另一种解决方案，可以减少垃圾收集的负担。具体来说，逃逸分析器确定对象是否可以在堆栈中分配，以及对象是否仅由单个线程访问。这样，当相应的方法返回时，堆中分配的对象可以自动收集，并且可以安全地删除仅由单个线程访问的对象上的同步。Choi等人。[16] 显示出，对于他们的基准测试，多达70%的对象可以在堆栈中分配，11%到92%的锁操作可以安全删除。综上所述，他们观察到了从2%到23%的性能改进。</p>
<hr>
<p>思路：模仿此文压缩算法，把所有对象压缩以后程序继续执行，经过多次gc后仍保持压缩的对象则放入低功耗内存中。（得先试一下每种负载中到底有多少冷对象）</p>
<h2 id="2-Tuning-garbage-collection-in-an-embedded-Java-environment"><a href="#2-Tuning-garbage-collection-in-an-embedded-Java-environment" class="headerlink" title="2. Tuning garbage collection in an embedded Java environment"></a>2. Tuning garbage collection in an embedded Java environment</h2><p>主要思路：<br>shuts off memory banks that do not hold live data.</p>
<p>个人疑问：</p>
<ul>
<li>模拟器如何实现shut off？<ul>
<li>读后感想：难道是把voltage设为0？</li>
</ul>
</li>
</ul>
<p>memory energy主要包括 dynamic energy 和 leakage energy</p>
<ul>
<li>when a memory array is referenced or precharged, 动态功耗就会产生。</li>
<li>本文主要解决的是leakage energy。方法：integrated hardware-software strategy.</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><img src="/2020/06/29/垃圾回收功耗优化论文阅读/Fig2_in_paper2.png" alt=""></p>
<p>（疑问：模拟器能够区分RAM和ROM吗？）</p>
<ol>
<li>ROM一旦被激活就不会再关掉，因此它只有在首次引用时才会被激活，从而减少程序执行过程中没有用到的memory banks的leakage energy。</li>
<li>将SRAM划分为banks，根据是否装有存活对象决定是否断电。</li>
<li>datapath energy = execution energy + gc energy</li>
<li>gc energy = mark energy + sweep energy + compact energy(if used)</li>
<li>memory energy = heap + runtime stack + KVM &amp; class lib(see fig.2)</li>
<li>对SRAM采用的功耗模型与用于cache的模型类似。每个bank的大小以及bank的数量是可调的。</li>
<li>每个bank有三种状态：read/write, active（有存活对象但没有读写操作）, inactive（没有存活对象）</li>
<li>read/write 和 active 状态产生动态功耗，inactive状态产生少量静态功耗</li>
</ol>
<h3 id="能耗特点及优化"><a href="#能耗特点及优化" class="headerlink" title="能耗特点及优化"></a>能耗特点及优化</h3><p><img src="/2020/06/29/垃圾回收功耗优化论文阅读/Fig5_in_paper2.png" alt=""></p>
<p>A.断电法：</p>
<ol>
<li>75.6%的heap energy来自leakage</li>
<li>将无用bank断电后，heap energy减少了31%， 90%是因为leakage的减少。</li>
<li>访问断电的bank会带来额外的开销。</li>
</ol>
<p>提前gc法：</p>
<ol>
<li>当对象变成垃圾后，在它被回收之前还是会持续产生能耗，因此提高gc的频率可以适当减低能耗，当然需要与gc本身的能耗做平衡。</li>
<li>提高gc频率的策略：k-allocation<ul>
<li>每经过k次allocation后就调用一次gc</li>
<li><img src="/2020/06/29/垃圾回收功耗优化论文阅读/Fig9_in_paper2.png" alt=""></li>
</ul>
</li>
</ol>
<p>B.调整位置法：</p>
<ol>
<li>原本对象分配空间不考虑位置，即整个heap使用一个free list。现令每个bank单独维护一个free list，尽量将对象分配在active bank上。即active-bank-first allocation。</li>
<li>Active Bank+：结合了active-bank-first allocation以及当现有的active bank无法满足分配要求时触发gc的策略。</li>
</ol>
<p>以上，Active Bank+最佳。对比结果：<br><img src="/2020/06/29/垃圾回收功耗优化论文阅读/Fig10_in_paper2.png" alt=""></p>
<p>C.Compact 策略：</p>
<ol>
<li>原本，heap将permanent object放在一个特定区域，现指定几个特定的bank作为这个特定的区域来存放permanent objects。</li>
<li>好处：当新的permanent object创建时无需移动dynamic object。</li>
<li>缺点：当permanent和dynamic对象都存在时需要同时激活至少2个bank。</li>
<li>结果：Active Bank+结合compact策略效果最优。</li>
</ol>
<p>D.还有一个M&amp;C2：<br>采用Lisp2算法代替KVM中原本的break table-based算法。（break table是更新reference时要用到的）<br>好处：能够处理不同大小的对象，并维持了对象被创建后的顺序，<br>坏处：在每个对象的header中需要添加一个4 byte的指针域。</p>
<p>MC2的好处：</p>
<ul>
<li>可以根据对象的生命周期移动对象。例如：生命周期相近的对象放到同一个bank中。</li>
<li>更新reference更高效。</li>
</ul>
<p>E.调整Heap大小以及bank数量：<br><img src="/2020/06/29/垃圾回收功耗优化论文阅读/Fig14_in_paper2.png" alt=""></p>
<h3 id="相关工作-1"><a href="#相关工作-1" class="headerlink" title="相关工作"></a>相关工作</h3><ol>
<li>Catthoor et al. [1998], Kandemir et al. [2000], and Vijaykrishnan et al. [2000] ：程序转换可以非常有效地降低以数组为主导的嵌入式应用程序的内存能量</li>
<li>Lebeck et al. and Delaluzetal 提出了基于操作系统和基于编译器/硬件的优化策略，以降低动态功耗</li>
</ol>
<hr>
<h2 id="3-Impact-of-GC-Design-on-Power-and-Performance-for-Android"><a href="#3-Impact-of-GC-Design-on-Power-and-Performance-for-Android" class="headerlink" title="3. Impact of GC Design on Power and Performance for Android"></a>3. Impact of GC Design on Power and Performance for Android</h2><p>主要思路：<br>采用不同的GC策略，观察其对android设备的能耗和性能影响。</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS: Dalvik Concurrent Mark-Sweep（安卓内部gc）</p>
<ol>
<li><p>Dalvik GC通常作为C编码的后台守护进程，在自己的本地Linux线程中并发运行，应用程序级Java变异器线程（mutator）也被调度为本地Linux线程</p>
<ul>
<li>Dalvik的组成部分包括：GC deamon, JIT compiler, signal catcher, main thread, application threads</li>
<li>mutator thread: 即application thread</li>
</ul>
</li>
<li><p>CMS在每个collection cycle开始时将所有mutator threads 挂起，扫描heap roots, 然后在mark开始之前恢复被挂起的线程，随后并发进行mark。</p>
</li>
<li>当并发的mark阶段结束后，再次将mutator threads挂起，mark剩下的对象…然后恢复挂起的线程，再进行sweep。</li>
</ol>
<ul>
<li>targetUtil: 每次GC结束后用来调整heap大小的值</li>
<li>softLimit: 某个阈值</li>
<li>CSB 阈值：softLimit - 某个delta</li>
</ul>
<ol start="4">
<li>CMS 被触发的条件：</li>
</ol>
<ul>
<li>allocation 超过CSB阈值，触发background GC</li>
<li>allocation 超过softLimit 或 allocation失败， 触发 foreground GC</li>
<li>显式GC，当 System.gc() 被调用时。</li>
</ul>
<h3 id="Generational-CMS"><a href="#Generational-CMS" class="headerlink" title="Generational CMS"></a>Generational CMS</h3><ol>
<li>generational 即，假定 最近创建的对象有较低的存活概率，将堆分为young和mature两个部分。</li>
<li>Minor GC 将young区域中存活的对象放到mature区域中。</li>
<li>major GC则检测整个区域，包括young 和 mature</li>
<li>Gen CMS 即 在 CMS的基础上，将新分配的对象当作young，将GC后存活的对象当作old。</li>
<li>Gen CMS 与 CMS 触发GC的条件相同，只不过被触发的变成了minor GC，而major GC 只有当存活的对象已经超过了softLimit才会被触发。</li>
</ol>
<h3 id="CMSFly"><a href="#CMSFly" class="headerlink" title="CMSFly"></a>CMSFly</h3><ol>
<li>当CMS进行 mark 操作时，有个stop-the-world阶段，CMSFly则解决这个问题。</li>
<li>当一个mutator thread的root已经被mark之后，CMSFly则立即通知它继续执行(本来是标记完一轮之后才继续执行)。</li>
</ol>
<h3 id="Concurrency-Policies"><a href="#Concurrency-Policies" class="headerlink" title="Concurrency Policies"></a>Concurrency Policies</h3><ol>
<li>background: 由GC deamon完成</li>
<li>foreground: 由mutator完成，与其他线程并行。</li>
</ol>
<h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><ol>
<li>增加堆大小并不一定能减少能耗</li>
<li>当GC全部是由GC deamon在后台完成时，能耗增加了。</li>
<li>调整heap 增长策略或并发性能减少能耗。</li>
<li><p>foreground GC 改善minimum mutator utilization（与响应度相关的指标）。而background和generational策略则更适用于large heap。</p>
</li>
<li><p>不同的GC策略在不同benchmark上的能耗表现如下：(没有绝对更优，取决于benchmark以及系统配置)<br><img src="/2020/06/29/垃圾回收功耗优化论文阅读/Fig8_in_paper3.png" alt=""></p>
</li>
</ol>
<h3 id="相关工作-2"><a href="#相关工作-2" class="headerlink" title="相关工作"></a>相关工作</h3><ol>
<li>结合Mark-Sweep Compact和引用计数(An energy efficient garbage collector for Java embeded devices)</li>
<li>Tuning garbage collection in an embedded Java environment，即文章2</li>
</ol>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2020/06/15/Edge-Computing相关论文-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/15/Edge-Computing相关论文-1/" itemprop="url">Edge-Computing相关论文-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-15T15:36:52+08:00">
                2020-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文阅读/" itemprop="url" rel="index">
                    <span itemprop="name">论文阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,522
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Edge-Computing相关论文阅读（一）"><a href="#Edge-Computing相关论文阅读（一）" class="headerlink" title="Edge Computing相关论文阅读（一）"></a>Edge Computing相关论文阅读（一）</h1><blockquote>
<p>主要介绍两篇综述类论文</p>
</blockquote>
<h2 id="1-Right-Provisioned-IoT-Edge-Computing-An-Overview"><a href="#1-Right-Provisioned-IoT-Edge-Computing-An-Overview" class="headerlink" title="1. Right-Provisioned IoT Edge Computing: An Overview"></a>1. Right-Provisioned IoT Edge Computing: An Overview</h2><p>(Great Lakes Symposium on VLSI 2019 (GLSVLSI’19) )</p>
<h3 id="作者："><a href="#作者：" class="headerlink" title="作者："></a>作者：</h3><p>Tosiron Adegbija, Roman Lysecky, and Vinu Vijay Kumar</p>
<p>Department of Electrical &amp; Computer Engineering, University of Arizona, Tucson, AZ, USA;<br>Google, Mountain View, CA</p>
<h3 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h3><p>物联网（IoT）上的边缘计算是一种越来越流行的范例，其中计算越来越靠近数据源（即边缘设备）。 边缘计算可减轻因响应时间，通信带宽，数据安全性和隐私，能源消耗等增加而导致的基于云计算的开销。但是，鉴于新兴物联网设备的潜在严格资源限制和功能要求，边缘计算绝不能<strong>被过度或不足地配置</strong>。 在本文中，我们概述了正确配置的IoT边缘计算问题，其中IoT设备配备了“足够”资源，即使在设计时可能没有明确定义“足够”时也是如此。 我们<strong>重点介绍了一些研究方向和关键挑战，以实现正确配置的物联网边缘计算</strong>。</p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol>
<li>本文所描述的边缘计算是指在边缘设备上进行计算，区别于MEC（在基站或路由器上进行计算）</li>
<li>正确配置(right-provisioned)是指：既不使得设备性能降低又能合理利用设备资源</li>
<li><p>正确配置应该是针对系统的，而不是针对应用的，因此获知系统的行为信息十分重要。而大多数物联网设备涉及一些可变性，在运行期间，应用程序、系统输入、目标功能或用户要求可能会发生巨大变化。</p>
</li>
<li><p>定义：</p>
</li>
</ol>
<ul>
<li>under-provisioned: 影响了功能/性能</li>
<li>over-provisioned: 资源过剩</li>
</ul>
<ol start="5">
<li>粒度：</li>
</ol>
<ul>
<li>task specific → application specific → domain specific → general<br>(domain-specific: 提供更好的应用程序灵活性，并且对于执行各种相似应用程序的系统而言更好。)</li>
</ul>
<ol start="6">
<li>static VS dynamic</li>
</ol>
<ul>
<li><p>大多数IoT设备是静态配置的，需要提前获知整个系统的信息。静态配置适用于只执行单个应用程序或一些已知其先验特征的应用程序。</p>
</li>
<li><p>动态配置能够满足系统在运行过程中发生变化的要求</p>
</li>
</ul>
<ol start="7">
<li>挑战</li>
</ol>
<ul>
<li><p>HLS(hign-level synthesis)</p>
<ul>
<li>timing-driven low-power right-provisioned：<br>为系统的各个组件选择合适的时钟域和频率，以使组合延迟小于总延迟约束，同时满足功率约束</li>
<li>新兴的HLS方法必须提供形式化设计，合成和优化框架，以支持可精确合成的可精确计时系统模型，从而使各种不同的计算方式具有明确的综合规范</li>
<li>这些新的HLS方法必须能够自动提取与现有的性能驱动的HLS工具/方法无缝集成所需的组件级和系统级综合约束。</li>
<li>新的HLS方法必须支持设计方法，事件驱动的通信以及在给定系统需求和约束的情况下进行自我时钟优化以优化能耗。</li>
</ul>
</li>
<li><p>计算卸载</p>
<ul>
<li>为了满足功能需求和系统约束，需要动态计算迁移方案来自适应地确定必须执行的计算。（协调计算开销与卸载开销）</li>
</ul>
</li>
<li><p>threat detection</p>
</li>
<li>Energy efficiency </li>
<li>adaptive memories</li>
</ul>
<h2 id="2-Cost-Aware-Cloudlet-Placement-in-Edge-Computing-Systems"><a href="#2-Cost-Aware-Cloudlet-Placement-in-Edge-Computing-Systems" class="headerlink" title="2. Cost-Aware Cloudlet Placement in Edge Computing Systems"></a>2. Cost-Aware Cloudlet Placement in Edge Computing Systems</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>边缘计算中的一项众所周知的挑战是战略性放置小云。 这项挑战的基本目标是最大程度地<strong>降低部署成本，并确保边缘服务用户的延迟最小</strong>。 我们通过设计一种可感知成本的Cloudlet放置方法来解决此挑战，该方法可将<strong>用户应用程序完全映射到适当的Cloudlet，同时确保其延迟要求</strong>。 我们通过基于纽约市OpenData进行广泛的实验来研究我们提出的方法的有效性。 结果表明，我们的方法获得了接近最佳成本的解决方案，并且大大减少了执行时间。</p>
<h2 id="3-On-Multi-Access-Edge-Computing-A-Survey-of-the-Emerging-5G-Network-Edge-Cloud-Architecture-and-Orchestration"><a href="#3-On-Multi-Access-Edge-Computing-A-Survey-of-the-Emerging-5G-Network-Edge-Cloud-Architecture-and-Orchestration" class="headerlink" title="3. On Multi-Access Edge Computing: A Survey of the Emerging 5G Network Edge Cloud Architecture and Orchestration"></a>3. On Multi-Access Edge Computing: A Survey of the Emerging 5G Network Edge Cloud Architecture and Orchestration</h2><p>（IEEE Communications Surveys &amp; Tutorials）</p>
<h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>多访问边缘计算（MEC）是一个新兴的生态系统，旨在融合电信和IT服务，在无线电访问网络的边缘提供一个云计算平台。 MEC在边缘提供存储和计算资源，从而减少了移动最终用户的等待时间，并更有效地利用了移动回程和核心网络。 本文介绍了有关MEC的调查，重点介绍了<strong>基本的关键支持技术</strong>。 它在考虑单个服务和支持移动性的MEC平台网络的情况下精心设计了MEC编排，从而为不同的编排部署选项带来了光明。 此外，本文<strong>分析了MEC参考体系结构和主要部署方案</strong>，这些方案为应用程序开发人员，内容提供商和第三方提供了多租户支持。 最后，本文概述了当前的标准化活动，并进一步阐述了开放研究的挑战。</p>
<h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><h4 id="MEC-usecases-and-applications"><a href="#MEC-usecases-and-applications" class="headerlink" title="MEC usecases and applications"></a>MEC usecases and applications</h4><ol>
<li>计算卸载<ul>
<li>energy consumption</li>
<li>code partitioning</li>
<li>RAN awareness ( Gaining information on the RAN quality and user context before performing ofﬂoading can assist both the device and the network to make the best out of the MEC platform services )</li>
</ul>
</li>
<li>分布式内容交付与缓存<ul>
<li>context awareness</li>
<li>pre-caching</li>
<li>popularity prediction</li>
</ul>
</li>
<li>web性能增强<ul>
<li>content optimization (content awareness)</li>
<li>accelerated browsing</li>
<li>web acceleration: adapting the content size dynamically</li>
</ul>
</li>
<li>IoT和大数据<ul>
<li>data aggregation and big data analytics</li>
</ul>
</li>
<li>智能城市服务</li>
<li>应用感知与内容优化 </li>
</ol>
<h4 id="MEC-enabling-technologies"><a href="#MEC-enabling-technologies" class="headerlink" title="MEC enabling technologies"></a>MEC enabling technologies</h4><ol>
<li><p>cloud computing</p>
<ul>
<li>私有云、公有云等技术模型</li>
<li>Iaas、Paas、SaaS等服务模型</li>
</ul>
</li>
<li><p>VMs and Containers</p>
</li>
<li>NFV</li>
<li><p>SDN<br> By decoupling the control plane from the data plane and through the use of common APIs, SDN introduces a logical centralized control, which can easily instantiate and offer virtual network instances, by abstracting the underlying network infrastructure.</p>
</li>
<li><p>Network Slicing<br>It consists in slicing one network into multiple instances, each architected and optimized for a speciﬁc requirement and/or speciﬁc application/service</p>
</li>
</ol>
<h4 id="MEC-FrameWork-and-architecture"><a href="#MEC-FrameWork-and-architecture" class="headerlink" title="MEC FrameWork and architecture"></a>MEC FrameWork and architecture</h4><p><img src="/2020/06/15/Edge-Computing相关论文-1/MEC-framework.png" alt=""></p>
<h4 id="MEC-service-and-orchestration"><a href="#MEC-service-and-orchestration" class="headerlink" title="MEC service and orchestration"></a>MEC service and orchestration</h4><p>orchestration 包含这些属性：</p>
<ol>
<li>Resource allocation</li>
<li>Service placement</li>
<li>Edge selection</li>
<li>Reliability</li>
<li>Service mobility<ul>
<li>VM migration</li>
</ul>
</li>
<li>Joint optimization of VNFs and MEC services</li>
</ol>
<h4 id="MEC-deployment-issues-in-mobile-networks"><a href="#MEC-deployment-issues-in-mobile-networks" class="headerlink" title="MEC deployment issues in mobile networks"></a>MEC deployment issues in mobile networks</h4><ul>
<li><p>Orchestration Deployment Options </p>
<p><img src="/2020/06/15/Edge-Computing相关论文-1/orchestrator%20deployment%20options.png" alt=""></p>
<ul>
<li><p>Open-O: 由Linux Foundation支持的一个开源项目，该项目建立了运营商级的编排平台，以跨虚拟的SDN / NFV基础架构和旧版网络提供端到端的组合服务。 OPEN-O实现了灵活性，支持多域和多位置，并通过自动化提高了服务生命周期。它还通过三个业务流程模块的层次结构缩短了上市时间，从而加快了创新速度。这种编排层次结构由（i）启用端到端服务组合和交付的Global Service Orchestrator，（ii）负责NFV编排的NFV-O组成，其中考虑了范围广泛的VNFM和VIM中的各种VNF，以及（iii ）SDNOrchestrator，它通过不同的SDN控制器（例如OpenDaylight和ONOS）和/或传统的元素管理系统来提供网络连接和流量控制。 Open-O采用TOSCA，YANG数据模型，REST API，OpenStack，并通过各种SDN，NFV和旧版网络支持资源抽象，从而提供包括策略管理，安全性和其他管理功能在内的一组通用服务.</p>
</li>
<li><p>ECOMP: 该项目最初由AT＆T发起，后来移交给Linux Foundation。它专注于VNF管理和提供以软件为中心的网络功能，并利用云技术和网络虚拟化的优势提供自动化服务。 ECOMP定义了一个负责自动化端到端服务实例的主服务协调器，它与三种不同的Controller类型（即通常在云层内的基础结构控制器，网络控制器和应用程序控制器）进行交互。编排自动化配置过程，可编程性规则和由策略驱动的操作管理，考虑到网络数据和面向服务的分析，在实例化，修改和终止网络，应用程序或基础架构服务和资源方面实现了灵活性。 ECOMP扩展了ETSI MANO的范围，引入了资源控制器和策略组件的概念以及资源描述的概念，即元数据，用于虚拟环境的生命周期管理，从而实现了网络的敏捷性和弹性，同时缩短了时间，市场。为此，ECOMP支持开放云标准（例如OpenStack，OPNFV和TOSCA），并遵循Netconf，Yang配置和管理模型以及REST-API。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>Open Network Automation Platform (ONAP) : Open-O与ECOMP合并。</li>
</ul>
<blockquote>
<p>《边缘计算开源平台现状分析》<br>面向物联网端：EdgeXfoundry、ApacheEdgent<br>面向边缘云：CORD、Akraino EdgeStack<br>面向云边融合：Azure IoT Edge<br>面向构建边缘计算平台：</p>
<ul>
<li>网络管理：ONAP</li>
<li>容器技术：Docker</li>
<li>云平台： OpenStack</li>
<li>人工智能技术：Acumos</li>
</ul>
</blockquote>
<h4 id="Lessions-learned-and-research-challenges"><a href="#Lessions-learned-and-research-challenges" class="headerlink" title="Lessions learned and research challenges"></a>Lessions learned and research challenges</h4><ul>
<li>MEC Service Orchestration and Programmability </li>
<li>MEC Service Continuity and Mobility</li>
<li>Service enhancements: QoE and Resiliency</li>
<li>MEC Security and Privacy </li>
<li>MEC Service Monetization </li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>MEC是一项新兴技术，它通过网络提出了边缘云计算的技术优势，并支持多租户，允许第三方通过标准化API按需提供应用程序和服务。 MEC使无线电和网络层对应用程序提供商/开发人员可见，从而在QoE上提供了一系列新的进步。 MEC被认为是5G系统的关键新兴技术之一，这归功于它对回程和核心网络中的低延迟保证和容量增强的显着贡献。 MEC的成功从根本上取决于技术与ETSI NFV ISG的一致性，以在服务弹性和生命周期管理，服务移动性以及与网络资源的联合优化方面正确定义管理和协调系统。目前，MEC提出了一系列尚未解决的挑战。但是，考虑到其潜力，很明显，MEC将极大地提升移动通信的形态和体验。</p>
<h5 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h5><p>进一步了解相关开源项目研究内容，结合所了解的边缘计算方向挑战，寻找可入手的点。</p>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2020/06/08/service-placement相关文章/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/08/service-placement相关文章/" itemprop="url">service-placement相关文章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-08T15:54:11+08:00">
                2020-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文阅读/" itemprop="url" rel="index">
                    <span itemprop="name">论文阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,498
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="service-placement相关文章"><a href="#service-placement相关文章" class="headerlink" title="service-placement相关文章"></a>service-placement相关文章</h1><blockquote>
<p>无头苍蝇似的在各种顶会上寻找研究方向，在浏览了许多论文之后总觉得杂乱无章，收获甚少。终于发现一个较为感兴趣的方向，即service placement 服务放置问题。对这个问题甚是陌生，希望能从找到的这些文章中整理出一些思路。</p>
</blockquote>
<h2 id="顶会论文简介"><a href="#顶会论文简介" class="headerlink" title="顶会论文简介"></a>顶会论文简介</h2><table>
<thead>
<tr>
<th>论文</th>
<th>类型</th>
<th>研究内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>算法类</td>
<td>service placement + request scheduling</td>
</tr>
<tr>
<td>2</td>
<td>算法类</td>
<td>service placement + request routing</td>
</tr>
<tr>
<td>3</td>
<td>算法类</td>
<td>service placement ， user mobility</td>
</tr>
<tr>
<td>4</td>
<td>算法类</td>
<td>VNF placement ， budget &amp; capacity constraint</td>
</tr>
<tr>
<td>5</td>
<td>算法类</td>
<td>ML job placement ，interference</td>
</tr>
<tr>
<td>6</td>
<td>算法类</td>
<td>SFC placement ，throughput</td>
</tr>
<tr>
<td>7</td>
<td>算法类</td>
<td>DAG placement</td>
</tr>
<tr>
<td>8</td>
<td>算法类</td>
<td>application component placement</td>
</tr>
</tbody>
</table>
<h3 id="INFOCOM2019"><a href="#INFOCOM2019" class="headerlink" title="INFOCOM2019"></a>INFOCOM2019</h3><h4 id="1-Service-Placement-and-Request-Scheduling-for-Data-intensive-Applications-in-Edge-Clouds"><a href="#1-Service-Placement-and-Request-Scheduling-for-Data-intensive-Applications-in-Edge-Clouds" class="headerlink" title="1. Service Placement and Request Scheduling for Data-intensive Applications in Edge Clouds"></a>1. Service Placement and Request Scheduling for Data-intensive Applications in Edge Clouds</h4><h5 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h5><p>Vajiheh Farhadi, Fidan Mehmeti, Ting He, Tom La Porta, Hana Khamfroush, Shiqiang Wang, Kevin S Chan </p>
<p>Pennsylvania State University, University of Kentucky, IBM, ARL </p>
<h5 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h5><p>移动边缘计算使无线用户可以利用云计算的功能而不会造成较大的通信延迟。为了从边缘服务于数据密集型应用程序（例如增强现实，视频分析），除了需要CPU周期和用于计算的内存外，我们还需要<strong>用于存储服务器数据的存储资源和用于接收用户提供的数据的网络带宽</strong>。此外，在考虑系统稳定性和运营成本的同时，需要<strong>随时间调整数据放置以适应随时间变化的需求</strong>。我们通过提出一个两阶段规模的框架来解决此问题，该框架在存储，通信，计算和预算约束下共同优化服务（数据和代码）放置和请求调度。通过分析各种情况的难度，我们可以充分说明问题的复杂性。通过将问题转化为集合函数优化，我们开发了多项式时间算法，该算法在某些条件下可实现恒定因子近似。大量的综合和跟踪驱动的仿真表明，该算法可实现90％的最佳性能。</p>
<h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><ul>
<li>shared resource pool 共享资源池：<br> 服务迁移需要考虑service performance和migration cost之间的平衡。当某些边缘节点负载较重时，考虑使用非离用户最近的边缘节点。因此，标准化的开放式边缘计算环境应运而生，使同一地理环境内的边缘云形成一个共享资源池。</li>
<li><p>request scheduling 请求调度：<br>  探究用户请求应调度到哪个服务器上以使得一些参数（例如 cost、completion time）最优的问题。<br>  它决定是否/在何处调度每个请求，考虑通信、边缘云的计算能力以及其他限制。</p>
</li>
<li><p>service placement 服务放置：<br>  它决定如何在每个边缘云的存储容量内复制和放置每个服务（包括服务器代码和数据）</p>
</li>
</ul>
<h5 id="本文工作"><a href="#本文工作" class="headerlink" title="本文工作"></a>本文工作</h5><p>我们共同考虑数据密集型应用程序的服务放置和请求调度。 与[20]相比，我们将两个决策的时间尺度分开：<strong>服务放置发生在较大的范围（frames）以防止系统不稳定，而请求调度发生在较小的尺度（slots）以支持实时服务</strong>。 由于服务复制/迁移，我们还施加了预算约束来控制运营成本。 这些更改可在重新配置的成本和服务请求的性能之间实现可控的权衡，同时在根本的优化问题中引发关键的更改。</p>
<h4 id="2-Joint-Service-Placement-and-Request-Routing-in-Multi-cell-Mobile-Edge-Computing-Networks"><a href="#2-Joint-Service-Placement-and-Request-Routing-in-Multi-cell-Mobile-Edge-Computing-Networks" class="headerlink" title="2. Joint Service Placement and Request Routing in Multi-cell Mobile Edge Computing Networks"></a>2. Joint Service Placement and Request Routing in Multi-cell Mobile Edge Computing Networks</h4><h5 id="作者-1"><a href="#作者-1" class="headerlink" title="作者"></a>作者</h5><p>Konstantinos Poularakis, Jaime Llorca, Antonia M. Tulino, Ian Taylor, and Leandros Tassiulas </p>
<p>Department of Electrical Engineering and Institute for Network Science, Yale University, USA<br>Nokia Bell Labs, USA<br>Department of Electrical Engineering and Information Technologies, University of Naples Federico II, Italy<br>School of Computer Science and Informatics, Cardiff University, UK</p>
<h5 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h5><p>诸如增强现实，网络游戏和自动驾驶等创新移动服务的激增，刺激了人们对低延迟访问计算资源的需求日益增长，而这些延迟只能通过现有的集中式云系统无法满足。通过支持在最终用户附近的网络外围执行计算任务，移动边缘计算（MEC）有望成为满足低延迟服务需求的有效解决方案。尽管许多最新研究已经解决了确定服务任务的执行以及将用户请求路由到相应边缘服务器的问题，但重点主要放在高效利用计算资源上，而忽略了这样一个事实：<strong>需要存储数据以启用服务执行，并且许多新兴服务表现出不对称的带宽要求</strong>。为了填补这一空白，我们研究了在具有多维（存储-计算-通信）约束的支持MEC的mmulti-cell网络中，服务放置和请求路由的联合优化。我们表明，该问题概括了文献中的几个问题，并提出了一种使用随机舍入实现接近最佳性能的算法。评估结果表明，我们的方法可以有效利用可用资源，以最大程度地减少低延迟边缘云服务器所服务的请求数量。</p>
<h5 id="一些概念-1"><a href="#一些概念-1" class="headerlink" title="一些概念"></a>一些概念</h5><ul>
<li>面对的挑战：<ul>
<li>allocation of computation resources</li>
<li>non-trival amout of data to be prestored at BS</li>
<li>communication requirements of services<br>(不对称的双向通信，占用无线基站上行链路和下行链路带宽容量的不同部分)</li>
</ul>
</li>
</ul>
<h4 id="3-Adaptive-User-managed-Service-Placement-for-Mobile-Edge-Computing-An-Online-Learning-Approach"><a href="#3-Adaptive-User-managed-Service-Placement-for-Mobile-Edge-Computing-An-Online-Learning-Approach" class="headerlink" title="3. Adaptive User-managed Service Placement for Mobile Edge Computing: An Online Learning Approach"></a>3. Adaptive User-managed Service Placement for Mobile Edge Computing: An Online Learning Approach</h4><h5 id="作者-2"><a href="#作者-2" class="headerlink" title="作者"></a>作者</h5><p>Tao Ouyang, Rui Li, Xu Chen, Zhi Zhou, Xin Tang </p>
<p>School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China</p>
<h5 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h5><p>设想为云扩展的移动边缘计算（MEC）将云资源从网络核心推送到网络边缘，从而满足许多新兴的计算密集型移动应用程序的严格服务要求。现有的许多工作都集中在研究系统范围内的MEC服务放置问题，个性化服务性能优化而受到的关注较少。因此，在本文中，我们提出了一种新颖的<strong>自适应用户管理</strong>的服务放置机制，该机制可以<strong>联合优化用户的感知潜伏期和服务迁移成本，并通过用户偏好进行加权</strong>。为了克服未来信息的不可用和未知的系统动力学问题，我们将动态服务放置问题公式化为a contextual multiarmed bandit (MAB) 问题，然后提出一种基于汤普森采样的在线学习算法来探索动态MEC环境，进一步协助用户做出自适应服务放置决策。严格的理论分析和广泛的评估证明了所提出的自适应用户管理的服务放置机制的优越性能。</p>
<h4 id="4-Joint-Placement-and-Allocation-of-Virtual-Network-Functions-with-Budget-and-Capacity-Constraints"><a href="#4-Joint-Placement-and-Allocation-of-Virtual-Network-Functions-with-Budget-and-Capacity-Constraints" class="headerlink" title="4. Joint Placement and Allocation of Virtual Network Functions with Budget and Capacity Constraints"></a>4. Joint Placement and Allocation of Virtual Network Functions with Budget and Capacity Constraints</h4><h5 id="作者-3"><a href="#作者-3" class="headerlink" title="作者"></a>作者</h5><p>Gamal Sallam and Bo Ji </p>
<p>Department of Computer and Information Sciences, Temple University, Philadelphia, PA, U</p>
<h5 id="摘要-3"><a href="#摘要-3" class="headerlink" title="摘要"></a>摘要</h5><p>随着网络功能虚拟化（NFV）的出现，传统上可以在专用硬件上运行的网络服务现在可以使用托管在通用商品硬件上的虚拟网络功能（VNF）来实现。这种新的网络范例为网络服务提供商（ISP）提供了极大的灵活性，可以有效地操作其网络（收集网络统计信息，执行管理策略等）。但是，引入NFV要求进行投资以将VNF部署在某些网络节点（称为VNF节点）上，这必须考虑实际的限制，例如部署预算和VNF节点容量。为此，重要的是设计一个<strong>联合的VNF节点放置和容量分配算法，该算法可以在尊重此类实际约束的同时，最大化VNF节点完全处理的网络流量总量</strong>。与通常忽略预算约束或能力约束的大多数先前工作相反，我们明确考虑了两者。我们证明，考虑这些约束会带来一些新的挑战。具体而言，我们证明了所研究的问题不仅是NP难的，而且是非亚模的。为了解决这些挑战，我们引入了一种新颖的松弛方法，以使松弛放置子问题的目标函数变为亚模。利用这种有用的子模性质，我们提出了两种算法，它们分别对原始的非松弛问题实现了1/2（1-1 / e）和1/3（1-1 / e）的近似比。最后，我们使用跟踪驱动的仿真和基于综合网络设置的仿真，通过广泛的评估来证实所提出算法的有效性。</p>
<h4 id="5-Deep-Learning-based-Job-Placement-in-Distributed-Machine-Learning-Clusters"><a href="#5-Deep-Learning-based-Job-Placement-in-Distributed-Machine-Learning-Clusters" class="headerlink" title="5. Deep Learning-based Job Placement in Distributed Machine Learning Clusters"></a>5. Deep Learning-based Job Placement in Distributed Machine Learning Clusters</h4><h5 id="作者-4"><a href="#作者-4" class="headerlink" title="作者"></a>作者</h5><p>Yixin Bao, Yanghua Peng, Chuan Wu </p>
<p>Department of Computer Science, The University of Hong Kong</p>
<h5 id="摘要-4"><a href="#摘要-4" class="headerlink" title="摘要"></a>摘要</h5><p>生产机器学习（ML）集群通常托管各种分布式ML工作负载，例如语音识别，机器翻译。虽然作业之间的服务器共享可以提高资源利用率，但是位于同一地点的ML作业之间的干扰会导致性能严重下降。现有的群集调度程序（例如，Mesos）在其工作位置上是无干扰的，从而导致资源效率不佳。文献中已经研究了具有干扰意识的工作位置，但是使用详细的工作量分析和干扰建模进行了处理，这不是一般的解决方案。本文介绍了Harmony，这是一种深度学习驱动的ML群集调度程序，它<strong>以最小化干扰和最大化性能（即训练完成时间）的方式放置训练作业</strong>。Harmony基于精心设计的深度强化学习（DRL）框架，并补充了奖励建模。 DRL采用最先进的技术来稳定训练并提高收敛性，其中包括演员批评算法，作业意识动作空间探索和体验重播。鉴于通常缺乏对应于不同安置决策的奖励样本，我们建立了一个辅助奖励预测模型，该模型使用历史样本进行训练，并用于为看不见的安置产生奖励。在由6个GPU服务器组成的Kubernetes集群中使用实际ML工作负载进行的实验表明，就平均作业完成时间而言，Harmony的性能比典型的调度程序高25％。</p>
<h5 id="一些概念-2"><a href="#一些概念-2" class="headerlink" title="一些概念"></a>一些概念</h5><ul>
<li>本文所描述的interference：<br>创建在同一server上的不同类型的ML jobs，例如CPU-intensive, I/O intensive, network bandwith-intensive, 由于底层资源的共享而导致的干扰。</li>
</ul>
<h4 id="6-Octans-Optimal-Placement-of-Service-Function-Chains-in-Many-Core-Systems"><a href="#6-Octans-Optimal-Placement-of-Service-Function-Chains-in-Many-Core-Systems" class="headerlink" title="6. Octans: Optimal Placement of Service Function Chains in Many-Core Systems"></a>6. Octans: Optimal Placement of Service Function Chains in Many-Core Systems</h4><h5 id="作者-5"><a href="#作者-5" class="headerlink" title="作者"></a>作者</h5><p>Zhilong Zheng, Jun Bi, Heng Yu, Haiping Wang, Chen Sun, Hongxin Hu, Jianping Wu</p>
<p>Institute for Network Sciences and Cyberspace, Tsinghua University<br>Department of Computer Science, Tsinghua University<br>Beijing National Research Center for Information Science and Technology<br>School of Computing, Clemson University</p>
<h5 id="摘要-5"><a href="#摘要-5" class="headerlink" title="摘要"></a>摘要</h5><p>网络功能虚拟化（NFV）可以通过在具有多个核心的商用服务器上运行服务功能链（SFC），来提供服务交付灵活性并降低总体成本。用于将SFC放置在一台服务器中的现有解决方案将所有CPU内核视为相等，并将隔离的CPU内核分配给不同的网络功能（NF）。但是，高级服务器通常采用非统一内存访问（NUMA）架构来提高多核系统的可伸缩性。 CPU内核分为多个节点，由于<strong>跨节点内存访问和节点内资源争用而导致性能瓶颈</strong>。我们的评估表明，与最佳放置解决方案相比，随机选择将NF放置在SFC中的核心可能会降低39.2％的吞吐量。在本文中，我们提出了Octan，它是NFV协调器，可在多核系统中实现所有SFC的最大总吞吐量。 Octans首先将优化问题表述为非线性整数规划（NLIP）模型。然后，我们确定解决问题的关键因素是评估同一SFC或不同SFC中其他NF导致的NF吞吐量下降，即性能下降指数，并基于系统级性能指标提出正式而精确的预测模型。最后，我们提出了一种有效的启发式算法来快速找到接近最佳的放置解决方案。我们已经实现了Octans的原型。广泛的评估表明，与两种最先进的放置机制相比，Octan显着提高了总吞吐量26.7％〜51.8％，SFC性能的预测误差非常低（平均偏差为2.6％）。而且，Octans可以快速找到具有最佳间隙（1.2％〜3.5％）的接近最佳的放置解决方案。</p>
<h5 id="一些概念-3"><a href="#一些概念-3" class="headerlink" title="一些概念"></a>一些概念</h5><ul>
<li>NFV 网络功能虚拟化：对传统在专有硬件上运行的网络服务（例如路由器、防火墙和负载平衡器）进行虚拟化的方法。这些服务被打包为商用硬件上的虚拟机（VM），这样服务提供商便可以在标准服务器（而非专有服务器）上运行其网络。</li>
<li>SFC 服务功能链：网络包以network functions sequence的形式被处理，从而形成SFC。</li>
</ul>
<h5 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h5><p>现有解决方案将所有CPU内核视为相等，将隔离的CPU内核分配给不同的网络功能。</p>
<ul>
<li>随机选择支持SFC的CPU内核可能会严重损害吞吐量：（一个节点由多个CPU cores组成）<ul>
<li>跨节点内存访问引起的吞吐量瓶颈</li>
<li>节点内资源争用</li>
</ul>
</li>
</ul>
<h5 id="本文工作-1"><a href="#本文工作-1" class="headerlink" title="本文工作"></a>本文工作</h5><ul>
<li>用非线性整数编程模型解决问题</li>
<li>为了评估由于资源争用和链接而导致的性能下降指标，我们引入了一种正式的方法来查找性能指标，并提出了一种用于性能下降预测的准确模型。</li>
</ul>
<h3 id="SEC"><a href="#SEC" class="headerlink" title="SEC"></a>SEC</h3><h4 id="7-Linearize-Predict-and-Place-Minimizing-the-Makespan-for-Edge-based-Stream-Processing-of-Directed-Acyclic-Graphs-（2019）"><a href="#7-Linearize-Predict-and-Place-Minimizing-the-Makespan-for-Edge-based-Stream-Processing-of-Directed-Acyclic-Graphs-（2019）" class="headerlink" title="7. Linearize, Predict and Place: Minimizing the Makespan for Edge-based Stream Processing of Directed Acyclic Graphs （2019）"></a>7. Linearize, Predict and Place: Minimizing the Makespan for Edge-based Stream Processing of Directed Acyclic Graphs （2019）</h4><h5 id="作者-6"><a href="#作者-6" class="headerlink" title="作者"></a>作者</h5><p>Shweta Khare, Hongyang Sun, Julien Gascon-Samson, Kaiwen Zhang, Aniruddha Gokhale, Yogesh Barve, Anirban Bhattacharjee, and Xenofon Koutsoukos.</p>
<h5 id="摘要-6"><a href="#摘要-6" class="headerlink" title="摘要"></a>摘要</h5><p>在诸如智能电网之类的网络物理系统中发现的许多物联网应用，都必须对关键事件（例如供需不匹配）采取控制措施，这需要对流数据进行低延迟处理以进行快速事件检测和异常纠正。这些流应用程序通常采用有向非循环图（DAG）的形式，其中顶点表示运算符，边表示这些运算符之间的数据流。边缘计算由于能够在数据源附近提供低延迟处理的能力而作为一种很容易满足延迟关键的物联网应用程序需求的方法，最近引起了广泛的关注。为了获得边缘计算的好处，这些应用程序的组成运营商必须以一种合理的方式放置，通过<strong>权衡运营商之间的通信成本与由于运营商在同一资源受限的边缘上的同一地点而产生的干扰成本</strong>。为了解决这些挑战并大幅<strong>简化任意大小和拓扑的DAG的放置问题</strong>，我们提出了一种算法，该算法首先<strong>将任意流处理DAG转换为一组近似的线性链</strong>。随后，用于共处一地的线性链的数据驱动的等待时间预测模型用于通知操作员的位置，以使定义为DAG中所有路径的<strong>最大等待时间的延展时间最小化</strong>。我们使用Beagle Bone集群上代表边缘计算环境的各种DAG放置方案，通过经验评估我们的算法。</p>
<p>(DAG placement)</p>
<h4 id="8-Efficient-placement-of-multi-component-applications-in-edge-computing-systems-（2017）"><a href="#8-Efficient-placement-of-multi-component-applications-in-edge-computing-systems-（2017）" class="headerlink" title="8. Efficient placement of multi-component applications in edge computing systems （2017）"></a>8. Efficient placement of multi-component applications in edge computing systems （2017）</h4><h5 id="作者-7"><a href="#作者-7" class="headerlink" title="作者"></a>作者</h5><p>Tayebeh Bahreini and Daniel Grosu</p>
<p>Dept. of Computer Science, Wayne State University</p>
<h5 id="摘要-7"><a href="#摘要-7" class="headerlink" title="摘要"></a>摘要</h5><p>移动边缘计算（MEC）是一种新的范例，已被引入以解决移动云计算技术的低效率问题。 MEC背后的关键思想是通过将应用程序的计算转发到网络边缘而不是云数据中心来增强移动设备的功能。 MEC的主要挑战之一是确定移动应用程序组件在边缘服务器上的有效放置，从而最大程度地减少运行应用程序时产生的成本。在本文中，我们通过设计一种有效的启发式在线算法来解决边缘计算中的多组件应用程序放置问题。我们还提出了考虑到<strong>用户位置和网络功能的动态特性</strong>的多组件应用程序放置问题的混合整数线性规划公式。我们进行了广泛的实验，以评估该算法的性能。实验结果表明，该算法执行时间极短，并获得了最佳解。</p>
<h5 id="一些概念-4"><a href="#一些概念-4" class="headerlink" title="一些概念"></a>一些概念</h5><ul>
<li>challenging issues in MEC：用户移动性导致的应用组件放置问题</li>
<li>application graphs: 节点表示应用组件</li>
<li>application placement problem：可以视为两种图之间的映射问题</li>
</ul>
<h5 id="本文工作-2"><a href="#本文工作-2" class="headerlink" title="本文工作"></a>本文工作</h5><ul>
<li>将多组件应用程序放置问题的onine版本公式化为混合整数线性程序（MILP）</li>
<li>基于简单算法技术（例如匹配和局部搜索）的算法，并避免使用复杂的方法（例如基于马尔可夫决策过程的方法）</li>
<li>算法设计的主要思想是确定应用程序组件与边缘/核心服务器之间的最佳匹配，而无需考虑组件之间的通信需求，然后考虑组件之间的通信需求并使用本地搜索过程改善解决方案</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>service placement问题是指考虑如何在每个边缘云的存储容量内复制和放置每个服务的问题。</p>
</li>
<li><p>挑战：</p>
<ul>
<li>通常考虑优化服务器在storage、computation、communication方面的资源限制，以及用户的移动性</li>
<li>由于在同一资源受限的edge server上部署不同的service而导致的问题</li>
</ul>
</li>
<li><p>最新研究</p>
<ul>
<li>与请求调度、网络功能虚拟化（NFV）结合进行研究</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2019/06/29/wechat-project-summary/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/29/wechat-project-summary/" itemprop="url">微信小程序--入门与踩坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-29T19:12:04+08:00">
                2019-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/系统分析与设计/" itemprop="url" rel="index">
                    <span itemprop="name">系统分析与设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,029
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="微信小程序入门"><a href="#微信小程序入门" class="headerlink" title="微信小程序入门"></a>微信小程序入门</h2><p>微信小程序的官方文档提供了非常详细、完整的描述，为入门提供了很好的指导。</p>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">微信小程序指南</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/" target="_blank" rel="noopener">微信小程序组件</a></li>
</ul>
<p>还有API、框架等文档也在同一个目录下。</p>
<h3 id="组件分享"><a href="#组件分享" class="headerlink" title="组件分享"></a>组件分享</h3><p>微信小程序的实现与web网页的实现非常像，但是微信更加便捷，因为它提供了很多封装好的组件，下面介绍一些对于初学者来说觉得挺好用的组件。</p>
<h4 id="1-分页，tabbar："><a href="#1-分页，tabbar：" class="headerlink" title="1. 分页，tabbar："></a>1. 分页，tabbar：</h4><ul>
<li>小程序整体的标签页在app.json中设置即可，默认标签位置在页面底部，color设置标签颜色，selectedColor设置被选中标签颜色，list设置标签内容及对应路径：<br><img src="/2019/06/29/wechat-project-summary/tabbar.png" alt=""></li>
</ul>
<h4 id="2-从底部弹起的滚动选择器，picker："><a href="#2-从底部弹起的滚动选择器，picker：" class="headerlink" title="2. 从底部弹起的滚动选择器，picker："></a>2. 从底部弹起的滚动选择器，picker：</h4><ul>
<li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/picker.html" target="_blank" rel="noopener">官方文档</a></p>
</li>
<li><p>除了普通选择器和多列选择器，官方还提供了时间、日期、省市区选择器，真的方便又快捷，感恩。</p>
</li>
</ul>
<p>关于这部分就不再赘述，想起来再补充，基本上你需要的控件微信官方都有提供，在文档上一搜就有了。</p>
<h3 id="样式分享，强推-WeUI"><a href="#样式分享，强推-WeUI" class="headerlink" title="样式分享，强推 WeUI"></a>样式分享，强推 WeUI</h3><p>WeUI是一套同微信原生视觉体验一致的基础样式库,由微信官方设计团队为微信内网页和微信小程序量身设计,令用户的使用感知更加统一。</p>
<p>首先，微信小程序搜索 “WeUI”, 进入之后页面如下：</p>
<p><img src="/2019/06/29/wechat-project-summary/WeUI.png" alt=""></p>
<p>小程序提供了很多样例，这些样例都是符合<a href="https://developers.weixin.qq.com/miniprogram/design/" target="_blank" rel="noopener">微信小程序设计指南</a>的，简洁又美观，具有微信的特色。这些只是样例，我们可以依照这些样例进行页面设计，同时WeUI也提供了这些样例对应的代码，给我们太提供了很方便的学习案例。</p>
<p>下面介绍使用方法：</p>
<ul>
<li>首先，<a href="https://github.com/Tencent/weui-wxss/" target="_blank" rel="noopener">去github下载WeUI代码</a></li>
<li>在自己的微信小程序项目中引入样式文件，可直接引用dist/style/weui.wxss，或者单独引用dist/style/widget下的组件的wxss</li>
<li>若不知道如何使用样式文件，dist/example/下的代码即是WeUI提供的样例的具体实现。</li>
</ul>
<h2 id="一些坑和技巧"><a href="#一些坑和技巧" class="headerlink" title="一些坑和技巧"></a>一些坑和技巧</h2><p>微信小程序其实坑很少，项目经历的时间有点长，很多也已经忘记了，这里替一些还有些许印象的坑坑。</p>
<h4 id="console-log"><a href="#console-log" class="headerlink" title="console.log()"></a>console.log()</h4><p>console.log()可以在调试面板中打印日志，反正找bug我基本就靠这个了，根据查看不同位置的输出看与设想的符不符合来找到出错位置，但是有一天，它反过来摆了我一道。</p>
<p>事情是这样的，我在位置1打印了对象A的值，然后改变对象A的值为A’，然后在位置2再次打印对象A，结果位置1打印出来的值居然是改变后的A’，所以我一直以为是位置1之前的代码出了问题，花了很长的事件都没找出来。</p>
<p>事实上，js并不像C语言那样是严格地从上往下执行的。具体js代码的执行顺序可以参考<a href="https://www.jb51.net/article/127025.htm" target="_blank" rel="noopener">这篇博客</a></p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><h5 id="如何确保for循环执行完之后再执行某个promise？"><a href="#如何确保for循环执行完之后再执行某个promise？" class="headerlink" title="如何确保for循环执行完之后再执行某个promise？"></a>如何确保for循环执行完之后再执行某个promise？</h5><ul>
<li><p>举个例子：<br><img src="/2019/06/29/wechat-project-summary/eg1.png" alt=""></p>
<p><em>(个人理解，欢迎指教)</em><br>在getByCourseId返回时，then用来处理成功返回值，此时相当于在一个新开的线程里面执行then里面的代码，在单一的线程里面代码是按顺序执行的，所以在用foreach完成对res的处理之后，下一个promise操作才会被执行。之所以采用return是为了防止多层promise嵌套，提高代码可读性。</p>
</li>
</ul>
<h5 id="如何一次执行多个Promise？"><a href="#如何一次执行多个Promise？" class="headerlink" title="如何一次执行多个Promise？"></a>如何一次执行多个Promise？</h5><ul>
<li><p>还是这个例子：<br><img src="/2019/06/29/wechat-project-summary/eg2.png" alt=""></p>
<p>其中，蓝色框是一个promise操作，红色框是将promise操作存放到一个数组里。</p>
</li>
<li><p>最重要的步骤是这个：<br><img src="/2019/06/29/wechat-project-summary/eg3.png" alt=""></p>
<p><code>Promise.all</code>可以将多个Promise实例包装成一个新的Promise实例，在等待多个异步操作返回结果后再执行下一步时非常有用。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2019/06/29/MoneyDodo-project-summary/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/29/MoneyDodo-project-summary/" itemprop="url">MoneyDodo-项目管理总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-29T15:57:10+08:00">
                2019-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/系统分析与设计/" itemprop="url" rel="index">
                    <span itemprop="name">系统分析与设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,564
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇博客是关于课程大作业–“MoneyDodo”项目的项目管理总结，介绍一些项目中的收获。感谢我的组员们在初次开会的时候给我提供了作为项目经理的宝贵机会。</p>
<h3 id="1-关于团队组建与成员分工"><a href="#1-关于团队组建与成员分工" class="headerlink" title="1. 关于团队组建与成员分工"></a>1. 关于团队组建与成员分工</h3><p>首先，我们发现线下面对面的交流相比于线上的交流效率会高很多，所以我们团队7个人采用线下开会的方法，一共进行了4次小组会议，来讨论成员分工以及一些设计的细节。</p>
<p>关于成员的分工，我们充分考虑了每个成员的长处，尽量为成员们分配擅长的工作，例如有的同学修过“服务计算”这门课程，比较适合后端开发，而有的同学没有，又比如团队中的女成员对于UI界面具有更优的美感，所以安排她们进行UI设计和前端开发。当然，因为是学生阶段的课程项目，有的成员希望接触一些新的领域来拓展自己的技能，现学现用也未尝不可，所以结合成员们的长处和意见，最终确定了成员的角色分配，在项目初期就完成了前后端的分离。</p>
<h3 id="2-关于每次会议的经验总结"><a href="#2-关于每次会议的经验总结" class="headerlink" title="2. 关于每次会议的经验总结"></a>2. 关于每次会议的经验总结</h3><p>我们采用线下的会议，第一次的会议主要是确定角色和分工，每个人都到场并积极参与讨论，我觉得这是作为一名团队成员应有的素质，而不是出席会议却不参与讨论，静静坐在一旁。关于会议参与度我觉得我们团队每个人都非常好。</p>
<p>当然，会议肯定需要有人主持，一般来说，项目经理需要承担这个工作，而且需要有人进行会议记录，以便后续的回顾和总结。我们以轮流的方式进行会议记录，每场会议由不同的人进行记录和总结，减轻负担。而项目经理在每次会议需要做的工作主要有：</p>
<ul>
<li>确认前端和后端的工作成果和进度，若进度与计划不符，则要及时分析原因，并及时对计划作出调整。我们团队在进度方面做得还是比较好的，特别是后端，进度相当快，为前端提供了很多便利。</li>
<li>细化下一轮迭代的工作内容。因为我在一开始为团队编写了迭代周期的框架，我们后续的工作是按照这个框架开展的，我们将项目大致划分为三轮迭代，每次迭代完成一定的工作内容。因此我们每次开会需要细化每一轮迭代的工作内容，包括需求分析和设计，前端主要工作及分工，后端主要工作及分工。</li>
</ul>
<h3 id="3-关于沟通方式"><a href="#3-关于沟通方式" class="headerlink" title="3. 关于沟通方式"></a>3. 关于沟通方式</h3><p>在项目的实现过程中，完成不同功能模块、前端与后端的人员需要进行大量的沟通，以便进行不同功能模块的合并或连接以及前后端的衔接，因此，一种有效的沟通方式能够减少沟通成本，提高沟通效率，从而推进项目的进度，减少成员负担。我们主要采用两种沟通方式：</p>
<ul>
<li>可视化图形结构</li>
<li>文档</li>
</ul>
<p>可视化图形结构主要用于前期的需求分析与设计，各种UML图帮了很大的忙。项目前期阶段我们使用Umlet绘制了用例图、活动图、领域模型、状态模型等图，使用modao工具设计了UI界面图，这些图代替语言，让成员们更好地理解，后续工作的开展也是按照这些图进行的，保证了项目朝着正确的方向进展。</p>
<p>前后端的数据主要是通过API交互的，而如何使用后端编写的API已经通过API文档详细描述了，所以前端工程师只需要依靠一个API文档，就能顺利开展相应的工作，省去了与后端人员沟通的很多麻烦。</p>
<h3 id="PM个人总结与反思"><a href="#PM个人总结与反思" class="headerlink" title="PM个人总结与反思"></a>PM个人总结与反思</h3><p>首先，本次的项目是我真正意义上的第一个团队项目，一开始就从团队的角度出发。以往的项目大多是个人独立完成的，即使是小组，成员间的工作也较为分散，通常是各做各的，缺少沟通和合作，而且也没有总体的规划，常常是脑子里想到什么就开始写代码了，这样会导致代码结构混乱，写代码的效率低下，修改代码所花费的时间较多，而且常常由于沟通不够导致衔接出现问题，或者是重点方向出现偏差，最终需要重写代码等问题。而本次的项目不是从写代码入手的，而是从人员的分工开始，每个人以自己擅长的领域着手，前端或后台，分工明确。</p>
<p>第一次尝试项目经理这个角色，对团队合作有了更进一步的了解。其实团队合作是需要靠人指挥和带动的，否则成员可能会出现怠惰的现象，一拖再拖，而项目经理就是起到这样的作用，规划项目的进度，监督成员们的工作，促进成员间的交流合作。作为项目经理，我并没有完全尽到相应的责任，中间有段时间忽略了项目的进展，项目的进度停滞了2-3个星期，导致项目最终的成果与预期有部分偏差，这是我需要反思的地方。</p>
<p>总体来说，我觉得我们小组的成员为了这个项目都付出了很多工作，最终看到项目的成果我也觉得很有成就感，通过这个项目我学会了很多，带给我的经验也是非常有用的。感谢所有同伴及老师的帮助。</p>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2019/06/29/swsad-final-report/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/29/swsad-final-report/" itemprop="url">系分项目-个人小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-29T14:30:37+08:00">
                2019-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/系统分析与设计/" itemprop="url" rel="index">
                    <span itemprop="name">系统分析与设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  791
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-个人小结"><a href="#1-个人小结" class="headerlink" title="1. 个人小结"></a>1. 个人小结</h2><p>首先，作为团队的项目经理和前端成员，我帮助团队完成了写文档、画图、确定需求、管理团队、前端代码编写等工作。</p>
<p>总的来说，我们团队成功实现了项目的基本需求，但是与最初的计划有些许的偏差，这是我作为项目经理的失职。但是尽管我们后期有点懈怠了，我们还是在中期完成了大部分的工作，项目的进度也是持续的，迭代周期一和迭代周期二按时完成，迭代周期三拖了一点时间但也完成了。</p>
<p>下面介绍我的成果</p>
<h4 id="1-管理："><a href="#1-管理：" class="headerlink" title="1.管理："></a>1.管理：</h4><ul>
<li>集合人员，为成员合理分配角色，让前后端分离。这是大家开会共同讨论的结果: <a href="https://money-hub.github.io/Dashboard/02-team-profile.html" target="_blank" rel="noopener">团队与分工</a></li>
<li>编写迭代周期，监督大家根据迭代周期保证产出。<a href="https://github.com/money-hub/Dashboard/blob/master/iterations.md" target="_blank" rel="noopener">迭代周期</a></li>
</ul>
<h4 id="2-分析："><a href="#2-分析：" class="headerlink" title="2. 分析："></a>2. 分析：</h4><ul>
<li>需求分析：包括<a href="https://money-hub.github.io/Dashboard/06-02-use-cases.html" target="_blank" rel="noopener">设计用例以及绘制活动图</a></li>
</ul>
<h4 id="3-开发："><a href="#3-开发：" class="headerlink" title="3. 开发："></a>3. 开发：</h4><ul>
<li>实现了小程序端的发布任务和任务详情的界面及功能</li>
<li>通过前端调用帮助测试后端API，并为后端提出一些逻辑上的缺陷以及数据库字段的完善意见。</li>
</ul>
<h2 id="PSP2-1-统计"><a href="#PSP2-1-统计" class="headerlink" title="PSP2.1 统计"></a>PSP2.1 统计</h2><table>
<thead>
<tr>
<th>PSP阶段</th>
<th>耗时(h)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>计划</strong></td>
<td>5</td>
</tr>
<tr>
<td>预估任务完成的时间</td>
<td>5</td>
</tr>
<tr>
<td><strong>开发</strong></td>
<td>100</td>
</tr>
<tr>
<td>需求分析</td>
<td>10</td>
</tr>
<tr>
<td>生成设计文档</td>
<td>10</td>
</tr>
<tr>
<td>设计复审</td>
<td>0</td>
</tr>
<tr>
<td>代码规范</td>
<td>0</td>
</tr>
<tr>
<td>具体设计</td>
<td>10</td>
</tr>
<tr>
<td>具体编码</td>
<td>60</td>
</tr>
<tr>
<td>代码复审</td>
<td>0</td>
</tr>
<tr>
<td>测试</td>
<td>10</td>
</tr>
<tr>
<td><strong>报告</strong></td>
<td>7</td>
</tr>
<tr>
<td>测试报告</td>
<td>0</td>
</tr>
<tr>
<td>计算工作量</td>
<td>2</td>
</tr>
<tr>
<td>总结&amp;过程改进计划</td>
<td>5</td>
</tr>
<tr>
<td>合计</td>
<td>112</td>
</tr>
</tbody>
</table>
<h2 id="主要工作清单"><a href="#主要工作清单" class="headerlink" title="主要工作清单"></a>主要工作清单</h2><ul>
<li>最有苦劳的工作：关于发布任务功能的实现，需要与后端交互，而且整个项目最核心的也是这个任务管理系统，因此它涉及到了各个系统API的调用包括用户管理系统、任务管理系统、交易管理系统等。在实现功能的过程中，发现了后端API涉及的逻辑缺陷、数据库字段缺陷以及一些测试漏掉的功能缺陷等。需要与后端沟通，并等待后端修改，才能进行下一步的测试和编写，耗费的时间最长。</li>
</ul>
<h2 id="个人git总结"><a href="#个人git总结" class="headerlink" title="个人git总结"></a>个人git总结</h2><h4 id="1-Dashboard文档"><a href="#1-Dashboard文档" class="headerlink" title="1. Dashboard文档"></a>1. Dashboard文档</h4><p><img src="/2019/06/29/swsad-final-report/dashboard.png" alt=""></p>
<h4 id="2-小程序端代码"><a href="#2-小程序端代码" class="headerlink" title="2. 小程序端代码"></a>2. 小程序端代码</h4><p><img src="/2019/06/29/swsad-final-report/wechat.png" alt=""></p>
<h2 id="个人博客清单"><a href="#个人博客清单" class="headerlink" title="个人博客清单"></a>个人博客清单</h2><ul>
<li><a href="https://linqy71.github.io/2019/06/29/wechat-project-summary/">微信小程序–入门与踩坑</a></li>
<li><a href="https://linqy71.github.io/2019/06/29/MoneyDodo-project-summary/">MoneyDodo-项目管理总结</a></li>
</ul>
<h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><ul>
<li>感谢linshk同学前端后端两头跑，承担起了前端后端大部分的衔接工作，而且完成了前端40%的工作，并且以自己的小程序项目经验带动了小程序端工作的顺利进行，没有linshk同学，另外两个前端工程师可能要在泥潭里挣扎很久。</li>
<li>感谢liuyh同学作为后端的负责人，积极与前端进行沟通并及时解决存在的问题。</li>
<li>感谢liuwd同学独自一人承担起了web前端的所有工作。</li>
<li>感谢几次会议进行会议记录的朋友，替PM分担了好多工作。</li>
<li>感谢每次会议都不缺席的全体组员。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2019/05/25/系统分析与设计-HW5/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/25/系统分析与设计-HW5/" itemprop="url">系统分析与设计-HW5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-25T14:09:27+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/系统分析与设计/" itemprop="url" rel="index">
                    <span itemprop="name">系统分析与设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  425
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HW5"><a href="#HW5" class="headerlink" title="HW5"></a>HW5</h1><h2 id="使用-UMLet-建模："><a href="#使用-UMLet-建模：" class="headerlink" title="使用 UMLet 建模："></a>使用 UMLet 建模：</h2><h3 id="根据订旅馆建模文档，Asg-RH-pdf："><a href="#根据订旅馆建模文档，Asg-RH-pdf：" class="headerlink" title="根据订旅馆建模文档，Asg-RH.pdf："></a>根据订旅馆建模文档，<a href="https://sysu-swsad.github.io/swad-guide/material/Asg_RH.pdf" target="_blank" rel="noopener">Asg-RH.pdf</a>：</h3><h4 id="绘制用例图模型（到子用例）"><a href="#绘制用例图模型（到子用例）" class="headerlink" title="绘制用例图模型（到子用例）"></a>绘制用例图模型（到子用例）</h4><p>  <img src="/2019/05/25/系统分析与设计-HW5/reserveHotel.jpg" alt=""></p>
<h4 id="给出-make-reservation-用例的活动图"><a href="#给出-make-reservation-用例的活动图" class="headerlink" title="给出 make reservation 用例的活动图"></a>给出 make reservation 用例的活动图</h4><p>  <img src="/2019/05/25/系统分析与设计-HW5/makeResv.jpg" alt=""></p>
<h3 id="根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"><a href="#根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景" class="headerlink" title="根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"></a>根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景</h3><h4 id="分别用多泳道图建模三个场景的业务过程"><a href="#分别用多泳道图建模三个场景的业务过程" class="headerlink" title="分别用多泳道图建模三个场景的业务过程"></a>分别用多泳道图建模三个场景的业务过程</h4><blockquote>
<p>场景一：x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。</p>
</blockquote>
<p><img src="/2019/05/25/系统分析与设计-HW5/scene_1.jpg" alt=""></p>
<blockquote>
<p>场景二：随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。</p>
</blockquote>
<p><img src="/2019/05/25/系统分析与设计-HW5/scene2.jpg" alt=""></p>
<blockquote>
<p>场景三：x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。</p>
</blockquote>
<p><img src="/2019/05/25/系统分析与设计-HW5/scene_3.jpg" alt=""></p>
<h4 id="根据上述流程，给出快递柜系统最终的用例图模型"><a href="#根据上述流程，给出快递柜系统最终的用例图模型" class="headerlink" title="根据上述流程，给出快递柜系统最终的用例图模型"></a>根据上述流程，给出快递柜系统最终的用例图模型</h4><ul>
<li>用正常色彩表示第一个业务流程反映的用例</li>
<li>用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor</li>
<li>用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor</li>
</ul>
<p><img src="/2019/05/25/系统分析与设计-HW5/usecase.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="linqy71.github.io/2019/05/23/系统分析与设计-HW4/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="清音">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/mai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="曲率飞行">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/系统分析与设计-HW4/" itemprop="url">系统分析与设计-HW4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-23T14:20:41+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/系统分析与设计/" itemprop="url" rel="index">
                    <span itemprop="name">系统分析与设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,067
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HW4"><a href="#HW4" class="headerlink" title="HW4"></a>HW4</h1><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ol>
<li><p>用例的概念</p>
<ul>
<li>Use case is a collection of related success and failure scenarios that describe an actor using a system to support a goal.</li>
</ul>
</li>
<li><p>用例和场景的关系？什么是主场景或 happy path？</p>
<ul>
<li>Scenario is a specific sequence of actions and<br>interactions between actors and the system; it is also called a use<br>case instance. A use case represents a collection of scenarios.</li>
<li>The primary scenario（主场景／基本流） corresponds to the main system interactions, usually the ‘success’ scenario.</li>
</ul>
</li>
<li><p>用例有哪些形式？</p>
<ul>
<li>Three Common Use Case Formats : Brief, Casual, Fully</li>
</ul>
</li>
<li><p>对于复杂业务，为什么编制完整用例非常难？</p>
<ul>
<li>复杂业务设计的场景较多</li>
</ul>
</li>
<li><p>什么是用例图？</p>
<ul>
<li>用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。</li>
</ul>
</li>
<li><p>用例图的基本符号与元素？</p>
<ul>
<li><p><img src="/2019/05/23/系统分析与设计-HW4/usecase.png" alt=""></p>
</li>
<li><p>用例图包含六个基本元素：参与者(Actor)、用例(Use Case)、关联关系(Association)、包含关系(Include)、扩展关系(Extend)以及泛化关系(Generalization)</p>
</li>
</ul>
</li>
<li><p>用例图的画法与步骤</p>
<ul>
<li>确定参与者：在获取用例前首先要确定系统的参与者</li>
<li>识别用例：特定参与者希望系统提供什么功能，由哪个参与者触发、当系统改变状态时，是否通知参与者、是否存在影响系统的外部事件等。一般以动词开头描述某件事情。</li>
<li>确定用例间关系：确定用例间的关联关系、包含关系、扩展关系、泛化关系</li>
<li>识别外部系统和服务</li>
</ul>
</li>
<li><p>用例图给利益相关人与开发者的价值有哪些？</p>
<ul>
<li>合理的用例识别（制作的用例图），通常给团队带来以下利益：<ul>
<li>明确系统的业务范围、服务对象（角色）、外部系统与设备；</li>
<li>帮助识别技术风险，提前实施关键技术原型公关与学习；</li>
<li>易于评估项目工作量，合理规划迭代周期，规划人力需要；</li>
</ul>
</li>
<li>用例图能够让利益相关人更直观地了解到系统所能带来的好处</li>
</ul>
</li>
</ol>
<h2 id="建模练习题（用例模型）"><a href="#建模练习题（用例模型）" class="headerlink" title="建模练习题（用例模型）"></a>建模练习题（用例模型）</h2><blockquote>
<p>选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：<br>请使用用户的视角，描述用户目标或系统提供的服务<br>粒度达到子用例级别，并用 include 和 exclude 关联它们<br>请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例<br>尽可能识别外部系统和服务</p>
</blockquote>
<p><img src="/2019/05/23/系统分析与设计-HW4/xiecheng.jpg" alt=""></p>
<p><img src="/2019/05/23/系统分析与设计-HW4/didi.jpg" alt=""></p>
<ol>
<li><p>为什么相似系统的用例图是相似的？<br>因为相似的系统要实现的功能是相似的，业务逻辑相似，很多场景也一致，只是针对的对象不同。</p>
</li>
<li><p>如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术.<br>可以利用大数据分析，根据用户喜好，用户来自哪里，为用户推荐适合用户风格的酒店。</p>
</li>
<li><p>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用<br>用色彩标注出创新的用例或子用例，从而突出创新思路。</p>
</li>
<li><p>请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
<th>Imp</th>
<th>Est</th>
<th>How to demo</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>查找旅馆</td>
<td>25</td>
<td>3</td>
<td>可按地点、日期查找旅馆</td>
<td>调用地图API进行定位</td>
</tr>
<tr>
<td>2</td>
<td>下订单</td>
<td>20</td>
<td>2</td>
<td>选择好旅馆、房间类型和日期等信息后确认提交订单</td>
</tr>
<tr>
<td>3</td>
<td>支付订单</td>
<td>25</td>
<td>2</td>
<td>选择支付方式进行付款，可使用银行卡支付、微信支付、支付宝支付</td>
<td>需要调用外部系统的支付API</td>
</tr>
<tr>
<td>4</td>
<td>登录</td>
<td>20</td>
<td>1</td>
<td>人脸识别</td>
<td>需要调用相关接口</td>
</tr>
</tbody>
</table>
<ol start="5">
<li>根据任务4，参考 使用用例点估算软件成本，给出项目用例点的估算</li>
</ol>
<table>
<thead>
<tr>
<th>用例</th>
<th># 业务</th>
<th># 计算</th>
<th>原因</th>
<th>UC 权重</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找旅馆</td>
<td>4</td>
<td>3</td>
<td></td>
<td>简单</td>
</tr>
<tr>
<td>下订单</td>
<td>5</td>
<td>5</td>
<td></td>
<td>平均</td>
</tr>
<tr>
<td>支付订单</td>
<td>5</td>
<td>3</td>
<td></td>
<td>简单</td>
</tr>
<tr>
<td>登录</td>
<td>1</td>
<td>1</td>
<td></td>
<td>简单</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    <div>
      
    </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/mai.jpg" alt="清音">
            
              <p class="site-author-name" itemprop="name">清音</p>
              <p class="site-description motion-element" itemprop="description">“吾生也有涯，而知也无涯”</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/linqy71" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:275769386@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="220" height="86" src="//music.163.com/outchain/player?type=2&id=1060910&auto=1&height=66"></iframe>

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">清音</span>

  
</div>


  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
  </div>
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
